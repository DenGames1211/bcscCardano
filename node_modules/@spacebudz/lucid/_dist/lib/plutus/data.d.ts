import { type Exact, type Json } from "../mod.js";
export declare class Constr<T> {
  index: number;
  fields: T[];
  constructor(index: number, fields: T[]);
}
export type Data = bigint | string | Array<Data> | Map<Data, Data> | Constr<Data>;
export declare const Data: {
  readonly Bytes: (options?: {
    minLength?: number;
    maxLength?: number;
    enum?: string[];
  } | number) => string;
  readonly Integer: () => bigint;
  readonly Boolean: () => boolean;
  readonly Any: () => Data;
  readonly Array: <T>(items: T, options?: {
    minItems?: number;
    maxItems?: number;
    uniqueItems?: boolean;
  } | number) => Array<T>;
  readonly Map: <K, V>(keys: K, values: V, options?: {
    minItems?: number;
    maxItems?: number;
  } | number) => Map<K, V>;
  readonly Object: <T extends Record<string, unknown>>(properties: T, options?: {
    hasConstr?: boolean;
  }) => T;
  readonly Enum: <S extends unknown[], T extends Array<string | {
    [enum_key: string]: [...S];
  } | {
    [enum_key: string]: Record<string, unknown>;
  }>>(...items: T) => T[number];
  readonly Tuple: <T extends unknown[]>(items: [...T], options?: {
    hasConstr?: boolean;
  }) => T;
  readonly Nullable: <T>(item: T) => T | null;
  readonly /**
   * Convert plutus data to cbor encoded data.\
   * Or apply a shape and convert the provided data struct to cbor encoded data.
   */ to: <T = Data>(data: Exact<T>, type?: T) => string;
  readonly /** Convert cbor encoded data to plutus data */ from: <T = Data>(raw: string, type?: T) => T;
  readonly /**
   * Note Constr cannot be used here.\
   * Strings prefixed with '0x' are not UTF-8 encoded.
   */ fromMetadata: (json: Json) => Data;
  readonly /**
   * Note Constr cannot be used here, also only bytes/integers as json keys.
   */ toMetadata: (plutusData: Data) => Json;
  readonly void: () => string;
  readonly castFrom: <T = Data>(data: Data, type: T) => T;
  readonly castTo: <T>(struct: Exact<T>, type: T) => Data;
};
//# sourceMappingURL=data.d.ts.map