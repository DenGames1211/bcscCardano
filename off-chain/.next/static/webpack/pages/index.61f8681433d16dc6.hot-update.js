"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./src/utils/common.ts":
/*!*****************************!*\
  !*** ./src/utils/common.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAssetUtxo: () => (/* binding */ getAssetUtxo),\n/* harmony export */   getBrowserWallet: () => (/* binding */ getBrowserWallet),\n/* harmony export */   getScript: () => (/* binding */ getScript),\n/* harmony export */   getScript2: () => (/* binding */ getScript2),\n/* harmony export */   getTxBuilder: () => (/* binding */ getTxBuilder),\n/* harmony export */   getUtxoByTxHash: () => (/* binding */ getUtxoByTxHash),\n/* harmony export */   getUtxoByTxHashWithRetry: () => (/* binding */ getUtxoByTxHashWithRetry),\n/* harmony export */   lockAssetsWithDatum: () => (/* binding */ lockAssetsWithDatum)\n/* harmony export */ });\n/* harmony import */ var _meshsdk_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @meshsdk/core */ \"(pages-dir-browser)/./node_modules/@meshsdk/core/dist/index.js\");\n/* harmony import */ var _meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @meshsdk/core-csl */ \"(pages-dir-browser)/./node_modules/@meshsdk/core-csl/dist/index.js\");\n/* harmony import */ var _scripts_bet_plutus_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/scripts/bet.plutus.json */ \"(pages-dir-browser)/./src/scripts/bet.plutus.json\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__]);\n_meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\nconst blockchainProvider = new _meshsdk_core__WEBPACK_IMPORTED_MODULE_0__.BlockfrostProvider(\"preview3G3NLFawCSyrtNMZb06OfRknAxZgy1fb\");\nlet _wallet = null;\n/**\r\n * Lazily initialize (and cache) a BrowserWallet instance.\r\n *\r\n * @param walletName – the CIP-30 wallet extension id (e.g. 'lace', 'nami', etc.)\r\n * @throws if called on the server, or if the extension isn’t found, or if enable() fails\r\n */ async function getBrowserWallet() {\n    let walletName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"lace\";\n    // 1) Don't run in SSR\n    if (false) {}\n    // 2) Return the cached wallet if already connected\n    if (_wallet) {\n        return _wallet;\n    }\n    // 3) Make sure the extension is actually injected\n    const injected = window.cardano;\n    if (!injected || !injected[walletName]) {\n        throw new Error(\"No CIP-30 provider found for '\".concat(walletName, \"'. \") + \"Make sure you have the \".concat(walletName, \" extension installed and enabled.\"));\n    }\n    // 4) Try to enable (this will open the “Connect” popup)\n    try {\n        _wallet = await _meshsdk_core__WEBPACK_IMPORTED_MODULE_0__.BrowserWallet.enable(walletName);\n    } catch (err) {\n        const msg = (err === null || err === void 0 ? void 0 : err.message) || (err === null || err === void 0 ? void 0 : err.toString()) || \"Unknown error\";\n        throw new Error(\"Failed to enable '\".concat(walletName, \"': \").concat(msg));\n    }\n    return _wallet;\n}\nfunction getScript2() {\n    const scriptCbor = (0,_meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__.applyParamsToScript)(_scripts_bet_plutus_json__WEBPACK_IMPORTED_MODULE_2__.validators[0].compiledCode, []);\n    const scriptAddr = (0,_meshsdk_core__WEBPACK_IMPORTED_MODULE_0__.serializePlutusScript)({\n        code: scriptCbor,\n        version: \"V3\"\n    }).address;\n    return {\n        scriptCbor,\n        scriptAddr\n    };\n}\nfunction getScript() {\n    const scriptCbor = (0,_meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__.applyParamsToScript)(_scripts_bet_plutus_json__WEBPACK_IMPORTED_MODULE_2__.validators[0].compiledCode, []);\n    const script = {\n        code: scriptCbor,\n        version: \"V3\"\n    };\n    const scriptAddr = (0,_meshsdk_core__WEBPACK_IMPORTED_MODULE_0__.resolvePlutusScriptAddress)(script, 0);\n    return {\n        script,\n        scriptAddr\n    };\n}\n// reusable function to get a transaction builder\nfunction getTxBuilder() {\n    return new _meshsdk_core__WEBPACK_IMPORTED_MODULE_0__.MeshTxBuilder({\n        fetcher: blockchainProvider,\n        submitter: blockchainProvider\n    });\n}\n// reusable function to get a UTxO by transaction hash\nasync function getUtxoByTxHash(txHash) {\n    const utxos = await blockchainProvider.fetchUTxOs(txHash);\n    if (utxos.length === 0) {\n        throw new Error(\"UTxO not found\");\n    }\n    return utxos[0];\n}\n/**\r\n * Locks the given assets into your on‐chain contract, using the provided datum.\r\n *\r\n * @param assets     – an array of `{ unit: string; quantity: string }`\r\n * @param datumCtor  – a function that, given any input, returns the serialized datum you want to attach\r\n * @param datumInput – the raw input that your datum constructor needs (e.g. a pubKeyHash, a number, whatever)\r\n * @returns the transaction hash of the lock\r\n */ async function lockAssetsWithDatum(assets, datumCtor, datumInput) {\n    // 1) grab UTXOs and your change address\n    const utxos = await _wallet.getUtxos();\n    const [walletAddress] = await _wallet.getUsedAddresses();\n    // 2) get your script (address + validator, etc.)\n    const { scriptAddr } = getScript();\n    // 3) build the transaction\n    const txBuilder = getTxBuilder().txOut(scriptAddr, assets) // funds → script\n    .txOutDatumHashValue(datumCtor(datumInput)) // attach your custom datum\n    .changeAddress(walletAddress) // return change\n    .selectUtxosFrom(utxos); // pay from your UTXOs\n    await txBuilder.complete();\n    // 4) sign & submit\n    const unsignedTx = txBuilder.txHex;\n    const signedTx = await _wallet.signTx(unsignedTx);\n    const txHash = await _wallet.submitTx(signedTx);\n    return txHash;\n}\nasync function getAssetUtxo(param) {\n    let { scriptAddress, asset, datum } = param;\n    const provider = blockchainProvider;\n    const utxos = await provider.fetchAddressUTxOs(scriptAddress, asset);\n    console.log(\"UTxOs at script:\", utxos);\n    const dataHash = (0,_meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__.resolveDataHash)(datum);\n    //const dataHash = \"c34b76230b9670a097bdbfc9e85ea5f7e02dbc0399806594a3c62ec7fd93402a\"\n    console.log(\"Looking for dataHash:\", (0,_meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__.resolveDataHash)(datum));\n    //dataHash = \"78769eb5e5c09a9f5b6e6558bc1527d79a20d428f32ce78c404d0ddbb3bbcc4f\"\n    //console.log(\"script addr used: \", scriptAddress)\n    let utxo = utxos.find((utxo)=>{\n        return utxo.output.dataHash == dataHash;\n    });\n    return utxo;\n}\nasync function getUtxoByTxHashWithRetry(txHash) {\n    let retries = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10, delay = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1500;\n    for(let i = 0; i < retries; i++){\n        try {\n            const result = await blockchainProvider.fetchUTxOs(txHash);\n            if (result && result.length > 0) {\n                return result[0]; // oppure filtrare quello giusto se ce ne sono più\n            }\n        } catch (err) {\n            if (err.status === 404) {\n                console.log(\"Retrying fetchUTxOByTxHash... [\".concat(i + 1, \"/\").concat(retries, \"]\"));\n                await new Promise((res)=>setTimeout(res, delay));\n            } else {\n                throw err; // errore diverso da 404\n            }\n        }\n    }\n    throw new Error(\"Transaction \".concat(txHash, \" not found after \").concat(retries, \" attempts.\"));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy91dGlscy9jb21tb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFZdUI7QUFDa0Q7QUFDcEI7QUFHckQsTUFBTVEscUJBQXFCLElBQUlSLDZEQUFrQkEsQ0FBQ1MseUNBQXNDO0FBRXhGLElBQUlHLFVBQWdDO0FBQ3BDOzs7OztDQUtDLEdBQ00sZUFBZUM7UUFBaUJDLGFBQUFBLGlFQUFxQjtJQUMxRCxzQkFBc0I7SUFDdEIsSUFBSSxLQUE2QixFQUFFLEVBRWxDO0lBRUQsbURBQW1EO0lBQ25ELElBQUlGLFNBQVM7UUFDWCxPQUFPQTtJQUNUO0lBRUEsa0RBQWtEO0lBQ2xELE1BQU1JLFdBQVcsT0FBZ0JFLE9BQU87SUFDeEMsSUFBSSxDQUFDRixZQUFZLENBQUNBLFFBQVEsQ0FBQ0YsV0FBVyxFQUFFO1FBQ3RDLE1BQU0sSUFBSUMsTUFDUixpQ0FBNEMsT0FBWEQsWUFBVyxTQUM1QywwQkFBcUMsT0FBWEEsWUFBVztJQUV6QztJQUVBLHdEQUF3RDtJQUN4RCxJQUFJO1FBQ0ZGLFVBQVUsTUFBTVgsd0RBQWFBLENBQUNrQixNQUFNLENBQUNMO0lBQ3ZDLEVBQUUsT0FBT00sS0FBVTtRQUNqQixNQUFNQyxNQUFNRCxDQUFBQSxnQkFBQUEsMEJBQUFBLElBQUtFLE9BQU8sTUFBSUYsZ0JBQUFBLDBCQUFBQSxJQUFLRyxRQUFRLE9BQU07UUFDL0MsTUFBTSxJQUFJUixNQUFNLHFCQUFxQ00sT0FBaEJQLFlBQVcsT0FBUyxPQUFKTztJQUN2RDtJQUVBLE9BQU9UO0FBQ1Q7QUFFTyxTQUFTWTtJQUNkLE1BQU1DLGFBQWFwQixzRUFBbUJBLENBQ3BDRSxnRUFBdUIsQ0FBQyxFQUFFLENBQUNvQixZQUFZLEVBQ3ZDLEVBQUU7SUFHSixNQUFNQyxhQUFhekIsb0VBQXFCQSxDQUN0QztRQUFFMEIsTUFBTUo7UUFBWUssU0FBUztJQUFLLEdBQ2xDQyxPQUFPO0lBRVQsT0FBTztRQUFFTjtRQUFZRztJQUFXO0FB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SUFBSUssUUFBUSxDQUFDQyxNQUFRQyxXQUFXRCxLQUFLTDtZQUM3QyxPQUFPO2dCQUNMLE1BQU10RCxLQUFLLHdCQUF3QjtZQUNyQztRQUNGO0lBQ0Y7SUFDQSxNQUFNLElBQUlMLE1BQU0sZUFBeUMwRCxPQUExQm5DLFFBQU8scUJBQTJCLE9BQVJtQyxTQUFRO0FBQ25FIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGZsb3JpXFxEZXNrdG9wXFxCbG9ja2NoYWluXFxiY3NjQ2FyZGFub1xcb2ZmLWNoYWluXFxzcmNcXHV0aWxzXFxjb21tb24udHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gXCJub2RlOmZzXCI7XHJcbmltcG9ydCB7XHJcbiAgQXNzZXQsXHJcbiAgQmxvY2tmcm9zdFByb3ZpZGVyLFxyXG4gIEJyb3dzZXJXYWxsZXQsXHJcbiAgbUNvblN0cjAsXHJcbiAgTWVzaFR4QnVpbGRlcixcclxuICBNZXNoV2FsbGV0LFxyXG4gIHNlcmlhbGl6ZVBsdXR1c1NjcmlwdCxcclxuICBQbHV0dXNTY3JpcHQsXHJcbiAgcmVzb2x2ZVBsdXR1c1NjcmlwdEFkZHJlc3MsXHJcbiAgVVR4TyxcclxufSBmcm9tIFwiQG1lc2hzZGsvY29yZVwiO1xyXG5pbXBvcnQgeyBhcHBseVBhcmFtc1RvU2NyaXB0LCByZXNvbHZlRGF0YUhhc2ggfSBmcm9tIFwiQG1lc2hzZGsvY29yZS1jc2xcIjtcclxuaW1wb3J0IGJldEJsdWVwcmludCBmcm9tIFwiQC9zY3JpcHRzL2JldC5wbHV0dXMuanNvblwiO1xyXG5pbXBvcnQgeyB1c2VXYWxsZXQgfSBmcm9tIFwiQG1lc2hzZGsvcmVhY3RcIjtcclxuIFxyXG5jb25zdCBibG9ja2NoYWluUHJvdmlkZXIgPSBuZXcgQmxvY2tmcm9zdFByb3ZpZGVyKHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0JMT0NLRlJPU1RfS0VZISk7XHJcbiBcclxubGV0IF93YWxsZXQ6IEJyb3dzZXJXYWxsZXQgfCBudWxsID0gbnVsbDtcclxuLyoqXHJcbiAqIExhemlseSBpbml0aWFsaXplIChhbmQgY2FjaGUpIGEgQnJvd3NlcldhbGxldCBpbnN0YW5jZS5cclxuICpcclxuICogQHBhcmFtIHdhbGxldE5hbWUg4oCTIHRoZSBDSVAtMzAgd2FsbGV0IGV4dGVuc2lvbiBpZCAoZS5nLiAnbGFjZScsICduYW1pJywgZXRjLilcclxuICogQHRocm93cyBpZiBjYWxsZWQgb24gdGhlIHNlcnZlciwgb3IgaWYgdGhlIGV4dGVuc2lvbiBpc27igJl0IGZvdW5kLCBvciBpZiBlbmFibGUoKSBmYWlsc1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJyb3dzZXJXYWxsZXQod2FsbGV0TmFtZTogc3RyaW5nID0gXCJsYWNlXCIpOiBQcm9taXNlPEJyb3dzZXJXYWxsZXQ+IHtcclxuICAvLyAxKSBEb24ndCBydW4gaW4gU1NSXHJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcImdldEJyb3dzZXJXYWxsZXQoKSBjYW4gb25seSBiZSBjYWxsZWQgaW4gdGhlIGJyb3dzZXJcIik7XHJcbiAgfVxyXG5cclxuICAvLyAyKSBSZXR1cm4gdGhlIGNhY2hlZCB3YWxsZXQgaWYgYWxyZWFkeSBjb25uZWN0ZWRcclxuICBpZiAoX3dhbGxldCkge1xyXG4gICAgcmV0dXJuIF93YWxsZXQ7XHJcbiAgfVxyXG5cclxuICAvLyAzKSBNYWtlIHN1cmUgdGhlIGV4dGVuc2lvbiBpcyBhY3R1YWxseSBpbmplY3RlZFxyXG4gIGNvbnN0IGluamVjdGVkID0gKHdpbmRvdyBhcyBhbnkpLmNhcmRhbm87XHJcbiAgaWYgKCFpbmplY3RlZCB8fCAhaW5qZWN0ZWRbd2FsbGV0TmFtZV0pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgYE5vIENJUC0zMCBwcm92aWRlciBmb3VuZCBmb3IgJyR7d2FsbGV0TmFtZX0nLiBgICtcclxuICAgICAgYE1ha2Ugc3VyZSB5b3UgaGF2ZSB0aGUgJHt3YWxsZXROYW1lfSBleHRlbnNpb24gaW5zdGFsbGVkIGFuZCBlbmFibGVkLmBcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyA0KSBUcnkgdG8gZW5hYmxlICh0aGlzIHdpbGwgb3BlbiB0aGUg4oCcQ29ubmVjdOKAnSBwb3B1cClcclxuICB0cnkge1xyXG4gICAgX3dhbGxldCA9IGF3YWl0IEJyb3dzZXJXYWxsZXQuZW5hYmxlKHdhbGxldE5hbWUpO1xyXG4gIH0gY2F0Y2ggKGVycjogYW55KSB7XHJcbiAgICBjb25zdCBtc2cgPSBlcnI/Lm1lc3NhZ2UgfHwgZXJyPy50b1N0cmluZygpIHx8IFwiVW5rbm93biBlcnJvclwiO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZW5hYmxlICcke3dhbGxldE5hbWV9JzogJHttc2d9YCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gX3dhbGxldDtcclxufVxyXG4gXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTY3JpcHQyKCkge1xyXG4gIGNvbnN0IHNjcmlwdENib3IgPSBhcHBseVBhcmFtc1RvU2NyaXB0KFxyXG4gICAgYmV0Qmx1ZXByaW50LnZhbGlkYXRvcnNbMF0uY29tcGlsZWRDb2RlLFxyXG4gICAgW11cclxuICApO1xyXG4gXHJcbiAgY29uc3Qgc2NyaXB0QWRkciA9IHNlcmlhbGl6ZVBsdXR1c1NjcmlwdChcclxuICAgIHsgY29kZTogc2NyaXB0Q2JvciwgdmVyc2lvbjogXCJWM1wiIH0sXHJcbiAgKS5hZGRyZXNzO1xyXG4gXHJcbiAgcmV0dXJuIHsgc2NyaXB0Q2Jvciwgc2NyaXB0QWRkciB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NyaXB0KCkge1xyXG4gIGNvbnN0IHNjcmlwdENib3IgPSBhcHBseVBhcmFtc1RvU2NyaXB0KGJldEJsdWVwcmludC52YWxpZGF0b3JzWzBdLmNvbXBpbGVkQ29kZSwgW10pO1xyXG5cclxuICBjb25zdCBzY3JpcHQ6IFBsdXR1c1NjcmlwdCA9IHtcclxuICAgIGNvZGU6IHNjcmlwdENib3IsXHJcbiAgICB2ZXJzaW9uOiBcIlYzXCIsXHJcbiAgfTtcclxuICBjb25zdCBzY3JpcHRBZGRyID0gcmVzb2x2ZVBsdXR1c1NjcmlwdEFkZHJlc3Moc2NyaXB0LCAwKTtcclxuICByZXR1cm4geyBzY3JpcHQsIHNjcmlwdEFkZHIgfTtcclxufVxyXG4gXHJcbi8vIHJldXNhYmxlIGZ1bmN0aW9uIHRvIGdldCBhIHRyYW5zYWN0aW9uIGJ1aWxkZXJcclxuZXhwb3J0IGZ1bmN0aW9uIGdldFR4QnVpbGRlcigpIHtcclxuICByZXR1cm4gbmV3IE1lc2hUeEJ1aWxkZXIoe1xyXG4gICAgZmV0Y2hlcjogYmxvY2tjaGFpblByb3ZpZGVyLFxyXG4gICAgc3VibWl0dGVyOiBibG9ja2NoYWluUHJvdmlkZXIsXHJcbiAgfSk7XHJcbn1cclxuIFxyXG4vLyByZXVzYWJsZSBmdW5jdGlvbiB0byBnZXQgYSBVVHhPIGJ5IHRyYW5zYWN0aW9uIGhhc2hcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFV0eG9CeVR4SGFzaCh0eEhhc2g6IHN0cmluZyk6IFByb21pc2U8VVR4Tz4ge1xyXG4gIGNvbnN0IHV0eG9zID0gYXdhaXQgYmxvY2tjaGFpblByb3ZpZGVyLmZldGNoVVR4T3ModHhIYXNoKTtcclxuICBpZiAodXR4b3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVVHhPIG5vdCBmb3VuZFwiKTtcclxuICB9XHJcbiAgcmV0dXJuIHV0eG9zWzBdO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBEYXR1bSA9IFJldHVyblR5cGU8dHlwZW9mIG1Db25TdHIwPjtcclxuZXhwb3J0IHR5cGUgRGF0dW1Db25zdHJ1Y3RvcjxJbnB1dD4gPSAoaW5wdXQ6IElucHV0KSA9PiBEYXR1bTtcclxuZXhwb3J0IHR5cGUgVmFyaWFkaWNEYXR1bUNvbnN0cnVjdG9yPEFyZ3MgZXh0ZW5kcyBhbnlbXT4gPSAoLi4uYXJnczogQXJncykgPT4gRGF0dW07XHJcblxyXG4vKipcclxuICogTG9ja3MgdGhlIGdpdmVuIGFzc2V0cyBpbnRvIHlvdXIgb27igJBjaGFpbiBjb250cmFjdCwgdXNpbmcgdGhlIHByb3ZpZGVkIGRhdHVtLlxyXG4gKlxyXG4gKiBAcGFyYW0gYXNzZXRzICAgICDigJMgYW4gYXJyYXkgb2YgYHsgdW5pdDogc3RyaW5nOyBxdWFudGl0eTogc3RyaW5nIH1gXHJcbiAqIEBwYXJhbSBkYXR1bUN0b3IgIOKAkyBhIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGFueSBpbnB1dCwgcmV0dXJucyB0aGUgc2VyaWFsaXplZCBkYXR1bSB5b3Ugd2FudCB0byBhdHRhY2hcclxuICogQHBhcmFtIGRhdHVtSW5wdXQg4oCTIHRoZSByYXcgaW5wdXQgdGhhdCB5b3VyIGRhdHVtIGNvbnN0cnVjdG9yIG5lZWRzIChlLmcuIGEgcHViS2V5SGFzaCwgYSBudW1iZXIsIHdoYXRldmVyKVxyXG4gKiBAcmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gaGFzaCBvZiB0aGUgbG9ja1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvY2tBc3NldHNXaXRoRGF0dW08SW5wdXQ+KFxyXG4gIGFzc2V0czogQXNzZXRbXSxcclxuICBkYXR1bUN0b3I6IERhdHVtQ29uc3RydWN0b3I8SW5wdXQ+LFxyXG4gIGRhdHVtSW5wdXQ6IElucHV0XHJcbik6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgLy8gMSkgZ3JhYiBVVFhPcyBhbmQgeW91ciBjaGFuZ2UgYWRkcmVzc1xyXG4gIGNvbnN0IHV0eG9zID0gYXdhaXQgX3dhbGxldCEuZ2V0VXR4b3MoKTtcclxuICBjb25zdCBbd2FsbGV0QWRkcmVzc10gPSBhd2FpdCBfd2FsbGV0IS5nZXRVc2VkQWRkcmVzc2VzKCk7XHJcblxyXG4gIC8vIDIpIGdldCB5b3VyIHNjcmlwdCAoYWRkcmVzcyArIHZhbGlkYXRvciwgZXRjLilcclxuICBjb25zdCB7IHNjcmlwdEFkZHIgfSA9IGdldFNjcmlwdCgpO1xyXG5cclxuICAvLyAzKSBidWlsZCB0aGUgdHJhbnNhY3Rpb25cclxuICBjb25zdCB0eEJ1aWxkZXIgPSBnZXRUeEJ1aWxkZXIoKVxyXG4gICAgLnR4T3V0KHNjcmlwdEFkZHIsIGFzc2V0cykgICAgICAgICAgICAgICAgICAgLy8gZnVuZHMg4oaSIHNjcmlwdFxyXG4gICAgLnR4T3V0RGF0dW1IYXNoVmFsdWUoZGF0dW1DdG9yKGRhdHVtSW5wdXQpKSAgLy8gYXR0YWNoIHlvdXIgY3VzdG9tIGRhdHVtXHJcbiAgICAuY2hhbmdlQWRkcmVzcyh3YWxsZXRBZGRyZXNzKSAgICAgICAgICAgICAgICAvLyByZXR1cm4gY2hhbmdlXHJcbiAgICAuc2VsZWN0VXR4b3NGcm9tKHV0eG9zKTsgICAgICAgICAgICAgICAgICAgICAvLyBwYXkgZnJvbSB5b3VyIFVUWE9zXHJcblxyXG4gIGF3YWl0IHR4QnVpbGRlci5jb21wbGV0ZSgpO1xyXG5cclxuICAvLyA0KSBzaWduICYgc3VibWl0XHJcbiAgY29uc3QgdW5zaWduZWRUeCA9IHR4QnVpbGRlci50eEhleDtcclxuICBjb25zdCBzaWduZWRUeCA9IGF3YWl0IF93YWxsZXQhLnNpZ25UeCh1bnNpZ25lZFR4KTtcclxuICBjb25zdCB0eEhhc2ggPSBhd2FpdCBfd2FsbGV0IS5zdWJtaXRUeChzaWduZWRUeCk7XHJcblxyXG4gIHJldHVybiB0eEhhc2g7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBc3NldFV0eG8oe1xyXG4gIHNjcmlwdEFkZHJlc3MsXHJcbiAgYXNzZXQsXHJcbiAgZGF0dW0sXHJcbn06IHtcclxuICBzY3JpcHRBZGRyZXNzOiBzdHJpbmc7XHJcbiAgYXNzZXQ6IHN0cmluZztcclxuICBkYXR1bTogYW55O1xyXG59KSB7XHJcbiAgY29uc3QgcHJvdmlkZXIgPSBibG9ja2NoYWluUHJvdmlkZXI7XHJcbiAgY29uc3QgdXR4b3MgPSBhd2FpdCBwcm92aWRlci5mZXRjaEFkZHJlc3NVVHhPcyhcclxuICAgIHNjcmlwdEFkZHJlc3MsXHJcbiAgICBhc3NldCxcclxuICApO1xyXG4gIGNvbnNvbGUubG9nKFwiVVR4T3MgYXQgc2NyaXB0OlwiLCB1dHhvcyk7XHJcbiAgY29uc3QgZGF0YUhhc2ggPSByZXNvbHZlRGF0YUhhc2goZGF0dW0pO1xyXG4gIC8vY29uc3QgZGF0YUhhc2ggPSBcImMzNGI3NjIzMGI5NjcwYTA5N2JkYmZjOWU4NWVhNWY3ZTAyZGJjMDM5OTgwNjU5NGEzYzYyZWM3ZmQ5MzQwMmFcIlxyXG4gIGNvbnNvbGUubG9nKFwiTG9va2luZyBmb3IgZGF0YUhhc2g6XCIsIHJlc29sdmVEYXRhSGFzaChkYXR1bSkpO1xyXG4gIC8vZGF0YUhhc2ggPSBcIjc4NzY5ZWI1ZTVjMDlhOWY1YjZlNjU1OGJjMTUyN2Q3OWEyMGQ0MjhmMzJjZTc4YzQwNGQwZGRiYjNiYmNjNGZcIlxyXG4gIC8vY29uc29sZS5sb2coXCJzY3JpcHQgYWRkciB1c2VkOiBcIiwgc2NyaXB0QWRkcmVzcylcclxuIFxyXG5cclxuICBsZXQgdXR4byA9IHV0eG9zLmZpbmQoKHV0eG86IGFueSkgPT4ge1xyXG4gICAgcmV0dXJuIHV0eG8ub3V0cHV0LmRhdGFIYXNoID09IGRhdGFIYXNoO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gdXR4bztcclxufVxyXG5cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVdHhvQnlUeEhhc2hXaXRoUmV0cnkodHhIYXNoOiBzdHJpbmcsIHJldHJpZXMgPSAxMCwgZGVsYXkgPSAxNTAwKTogUHJvbWlzZTxhbnk+IHtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJldHJpZXM7IGkrKykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYmxvY2tjaGFpblByb3ZpZGVyLmZldGNoVVR4T3ModHhIYXNoKTtcclxuICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJldHVybiByZXN1bHRbMF07IC8vIG9wcHVyZSBmaWx0cmFyZSBxdWVsbG8gZ2l1c3RvIHNlIGNlIG5lIHNvbm8gcGnDuVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgICBpZiAoZXJyLnN0YXR1cyA9PT0gNDA0KSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFJldHJ5aW5nIGZldGNoVVR4T0J5VHhIYXNoLi4uIFske2kgKyAxfS8ke3JldHJpZXN9XWApO1xyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCBkZWxheSkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IGVycjsgLy8gZXJyb3JlIGRpdmVyc28gZGEgNDA0XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiAke3R4SGFzaH0gbm90IGZvdW5kIGFmdGVyICR7cmV0cmllc30gYXR0ZW1wdHMuYCk7XHJcbn1cclxuIl0sIm5hbWVzIjpbIkJsb2NrZnJvc3RQcm92aWRlciIsIkJyb3dzZXJXYWxsZXQiLCJNZXNoVHhCdWlsZGVyIiwic2VyaWFsaXplUGx1dHVzU2NyaXB0IiwicmVzb2x2ZVBsdXR1c1NjcmlwdEFkZHJlc3MiLCJhcHBseVBhcmFtc1RvU2NyaXB0IiwicmVzb2x2ZURhdGFIYXNoIiwiYmV0Qmx1ZXByaW50IiwiYmxvY2tjaGFpblByb3ZpZGVyIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0JMT0NLRlJPU1RfS0VZIiwiX3dhbGxldCIsImdldEJyb3dzZXJXYWxsZXQiLCJ3YWxsZXROYW1lIiwiRXJyb3IiLCJpbmplY3RlZCIsIndpbmRvdyIsImNhcmRhbm8iLCJlbmFibGUiLCJlcnIiLCJtc2ciLCJtZXNzYWdlIiwidG9TdHJpbmciLCJnZXRTY3JpcHQyIiwic2NyaXB0Q2JvciIsInZhbGlkYXRvcnMiLCJjb21waWxlZENvZGUiLCJzY3JpcHRBZGRyIiwiY29kZSIsInZlcnNpb24iLCJhZGRyZXNzIiwiZ2V0U2NyaXB0Iiwic2NyaXB0IiwiZ2V0VHhCdWlsZGVyIiwiZmV0Y2hlciIsInN1Ym1pdHRlciIsImdldFV0eG9CeVR4SGFzaCIsInR4SGFzaCIsInV0eG9zIiwiZmV0Y2hVVHhPcyIsImxlbmd0aCIsImxvY2tBc3NldHNXaXRoRGF0dW0iLCJhc3NldHMiLCJkYXR1bUN0b3IiLCJkYXR1bUlucHV0IiwiZ2V0VXR4b3MiLCJ3YWxsZXRBZGRyZXNzIiwiZ2V0VXNlZEFkZHJlc3NlcyIsInR4QnVpbGRlciIsInR4T3V0IiwidHhPdXREYXR1bUhhc2hWYWx1ZSIsImNoYW5nZUFkZHJlc3MiLCJzZWxlY3RVdHhvc0Zyb20iLCJjb21wbGV0ZSIsInVuc2lnbmVkVHgiLCJ0eEhleCIsInNpZ25lZFR4Iiwic2lnblR4Iiwic3VibWl0VHgiLCJnZXRBc3NldFV0eG8iLCJzY3JpcHRBZGRyZXNzIiwiYXNzZXQiLCJkYXR1bSIsInByb3ZpZGVyIiwiZmV0Y2hBZGRyZXNzVVR4T3MiLCJjb25zb2xlIiwibG9nIiwiZGF0YUhhc2giLCJ1dHhvIiwiZmluZCIsIm91dHB1dCIsImdldFV0eG9CeVR4SGFzaFdpdGhSZXRyeSIsInJldHJpZXMiLCJkZWxheSIsImkiLCJyZXN1bHQiLCJzdGF0dXMiLCJQcm9taXNlIiwicmVzIiwic2V0VGltZW91dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/utils/common.ts\n"));

/***/ })

});