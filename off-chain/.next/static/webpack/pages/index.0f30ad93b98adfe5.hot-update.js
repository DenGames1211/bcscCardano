"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./src/utils/common.ts":
/*!*****************************!*\
  !*** ./src/utils/common.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAssetUtxo: () => (/* binding */ getAssetUtxo),\n/* harmony export */   getBrowserWallet: () => (/* binding */ getBrowserWallet),\n/* harmony export */   getScript2: () => (/* binding */ getScript2),\n/* harmony export */   getTxBuilder: () => (/* binding */ getTxBuilder),\n/* harmony export */   getUtxoByTxHash: () => (/* binding */ getUtxoByTxHash),\n/* harmony export */   getUtxoByTxHashWithRetry: () => (/* binding */ getUtxoByTxHashWithRetry),\n/* harmony export */   lockAssetsWithDatum: () => (/* binding */ lockAssetsWithDatum)\n/* harmony export */ });\n/* harmony import */ var _meshsdk_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @meshsdk/core */ \"(pages-dir-browser)/./node_modules/@meshsdk/core/dist/index.js\");\n/* harmony import */ var _meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @meshsdk/core-csl */ \"(pages-dir-browser)/./node_modules/@meshsdk/core-csl/dist/index.js\");\n/* harmony import */ var _scripts_bet_plutus_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/scripts/bet.plutus.json */ \"(pages-dir-browser)/./src/scripts/bet.plutus.json\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__]);\n_meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\nconst blockchainProvider = new _meshsdk_core__WEBPACK_IMPORTED_MODULE_0__.BlockfrostProvider(\"preview3G3NLFawCSyrtNMZb06OfRknAxZgy1fb\");\nlet _wallet = null;\n/**\r\n * Lazily initialize (and cache) a BrowserWallet instance.\r\n *\r\n * @param walletName – the CIP-30 wallet extension id (e.g. 'lace', 'nami', etc.)\r\n * @throws if called on the server, or if the extension isn’t found, or if enable() fails\r\n */ async function getBrowserWallet() {\n    let walletName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"lace\";\n    // 1) Don't run in SSR\n    if (false) {}\n    // 2) Return the cached wallet if already connected\n    if (_wallet) {\n        return _wallet;\n    }\n    // 3) Make sure the extension is actually injected\n    const injected = window.cardano;\n    if (!injected || !injected[walletName]) {\n        throw new Error(\"No CIP-30 provider found for '\".concat(walletName, \"'. \") + \"Make sure you have the \".concat(walletName, \" extension installed and enabled.\"));\n    }\n    // 4) Try to enable (this will open the “Connect” popup)\n    try {\n        _wallet = await _meshsdk_core__WEBPACK_IMPORTED_MODULE_0__.BrowserWallet.enable(walletName);\n    } catch (err) {\n        const msg = (err === null || err === void 0 ? void 0 : err.message) || (err === null || err === void 0 ? void 0 : err.toString()) || \"Unknown error\";\n        throw new Error(\"Failed to enable '\".concat(walletName, \"': \").concat(msg));\n    }\n    return _wallet;\n}\nfunction getScript2() {\n    const scriptCbor = (0,_meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__.applyParamsToScript)(_scripts_bet_plutus_json__WEBPACK_IMPORTED_MODULE_2__.validators[0].compiledCode, []);\n    const scriptAddr = (0,_meshsdk_core__WEBPACK_IMPORTED_MODULE_0__.serializePlutusScript)({\n        code: scriptCbor,\n        version: \"V3\"\n    }).address;\n    return {\n        scriptCbor,\n        scriptAddr\n    };\n}\nfunction getScript() {\n    const scriptCbor = (0,_meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__.applyParamsToScript)(_scripts_bet_plutus_json__WEBPACK_IMPORTED_MODULE_2__.validators[0].compiledCode, []);\n    const script = {\n        code: scriptCbor,\n        version: \"V3\"\n    };\n    const scriptAddr = (0,_meshsdk_core__WEBPACK_IMPORTED_MODULE_0__.resolvePlutusScriptAddress)(script, 0);\n    return {\n        script,\n        scriptAddr\n    };\n}\n// reusable function to get a transaction builder\nfunction getTxBuilder() {\n    return new _meshsdk_core__WEBPACK_IMPORTED_MODULE_0__.MeshTxBuilder({\n        fetcher: blockchainProvider,\n        submitter: blockchainProvider\n    });\n}\n// reusable function to get a UTxO by transaction hash\nasync function getUtxoByTxHash(txHash) {\n    const utxos = await blockchainProvider.fetchUTxOs(txHash);\n    if (utxos.length === 0) {\n        throw new Error(\"UTxO not found\");\n    }\n    return utxos[0];\n}\n/**\r\n * Locks the given assets into your on‐chain contract, using the provided datum.\r\n *\r\n * @param assets     – an array of `{ unit: string; quantity: string }`\r\n * @param datumCtor  – a function that, given any input, returns the serialized datum you want to attach\r\n * @param datumInput – the raw input that your datum constructor needs (e.g. a pubKeyHash, a number, whatever)\r\n * @returns the transaction hash of the lock\r\n */ async function lockAssetsWithDatum(assets, datumCtor, datumInput) {\n    // 1) grab UTXOs and your change address\n    const utxos = await _wallet.getUtxos();\n    const [walletAddress] = await _wallet.getUsedAddresses();\n    // 2) get your script (address + validator, etc.)\n    const { scriptAddr } = getScript();\n    // 3) build the transaction\n    const txBuilder = getTxBuilder().txOut(scriptAddr, assets) // funds → script\n    .txOutDatumHashValue(datumCtor(datumInput)) // attach your custom datum\n    .changeAddress(walletAddress) // return change\n    .selectUtxosFrom(utxos); // pay from your UTXOs\n    await txBuilder.complete();\n    // 4) sign & submit\n    const unsignedTx = txBuilder.txHex;\n    const signedTx = await _wallet.signTx(unsignedTx);\n    const txHash = await _wallet.submitTx(signedTx);\n    return txHash;\n}\nasync function getAssetUtxo(param) {\n    let { scriptAddress, asset, datum } = param;\n    const provider = blockchainProvider;\n    const utxos = await provider.fetchAddressUTxOs(scriptAddress, asset);\n    console.log(\"UTxOs at script:\", utxos);\n    const dataHash = (0,_meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__.resolveDataHash)(datum);\n    //const dataHash = \"c34b76230b9670a097bdbfc9e85ea5f7e02dbc0399806594a3c62ec7fd93402a\"\n    console.log(\"Looking for dataHash:\", (0,_meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__.resolveDataHash)(datum));\n    //dataHash = \"78769eb5e5c09a9f5b6e6558bc1527d79a20d428f32ce78c404d0ddbb3bbcc4f\"\n    //console.log(\"script addr used: \", scriptAddress)\n    let utxo = utxos.find((utxo)=>{\n        return utxo.output.dataHash == dataHash;\n    });\n    return utxo;\n}\nasync function getUtxoByTxHashWithRetry(txHash) {\n    let retries = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10, delay = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1500;\n    for(let i = 0; i < retries; i++){\n        try {\n            const result = await blockchainProvider.fetchUTxOs(txHash);\n            if (result && result.length > 0) {\n                return result[0]; // oppure filtrare quello giusto se ce ne sono più\n            }\n        } catch (err) {\n            if (err.status === 404) {\n                console.log(\"Retrying fetchUTxOByTxHash... [\".concat(i + 1, \"/\").concat(retries, \"]\"));\n                await new Promise((res)=>setTimeout(res, delay));\n            } else {\n                throw err; // errore diverso da 404\n            }\n        }\n    }\n    throw new Error(\"Transaction \".concat(txHash, \" not found after \").concat(retries, \" attempts.\"));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy91dGlscy9jb21tb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQVl1QjtBQUNrRDtBQUNwQjtBQUdyRCxNQUFNUSxxQkFBcUIsSUFBSVIsNkRBQWtCQSxDQUFDUyx5Q0FBc0M7QUFFeEYsSUFBSUcsVUFBZ0M7QUFDcEM7Ozs7O0NBS0MsR0FDTSxlQUFlQztRQUFpQkMsYUFBQUEsaUVBQXFCO0lBQzFELHNCQUFzQjtJQUN0QixJQUFJLEtBQTZCLEVBQUUsRUFFbEM7SUFFRCxtREFBbUQ7SUFDbkQsSUFBSUYsU0FBUztRQUNYLE9BQU9BO0lBQ1Q7SUFFQSxrREFBa0Q7SUFDbEQsTUFBTUksV0FBVyxPQUFnQkUsT0FBTztJQUN4QyxJQUFJLENBQUNGLFlBQVksQ0FBQ0EsUUFBUSxDQUFDRixXQUFXLEVBQUU7UUFDdEMsTUFBTSxJQUFJQyxNQUNSLGlDQUE0QyxPQUFYRCxZQUFXLFNBQzVDLDBCQUFxQyxPQUFYQSxZQUFXO0lBRXpDO0lBRUEsd0RBQXdEO0lBQ3hELElBQUk7UUFDRkYsVUFBVSxNQUFNWCx3REFBYUEsQ0FBQ2tCLE1BQU0sQ0FBQ0w7SUFDdkMsRUFBRSxPQUFPTSxLQUFVO1FBQ2pCLE1BQU1DLE1BQU1ELENBQUFBLGdCQUFBQSwwQkFBQUEsSUFBS0UsT0FBTyxNQUFJRixnQkFBQUEsMEJBQUFBLElBQUtHLFFBQVEsT0FBTTtRQUMvQyxNQUFNLElBQUlSLE1BQU0scUJBQXFDTSxPQUFoQlAsWUFBVyxPQUFTLE9BQUpPO0lBQ3ZEO0lBRUEsT0FBT1Q7QUFDVDtBQUVPLFNBQVNZO0lBQ2QsTUFBTUMsYUFBYXBCLHNFQUFtQkEsQ0FDcENFLGdFQUF1QixDQUFDLEVBQUUsQ0FBQ29CLFlBQVksRUFDdkMsRUFBRTtJQUdKLE1BQU1DLGFBQWF6QixvRUFBcUJBLENBQ3RDO1FBQUUwQixNQUFNSjtRQUFZSyxTQUFTO0lBQUssR0FDbENDLE9BQU87SUFFVCxPQUFPO1FBQUVOO1FBQVlHO0lBQVc7QUFD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QUFJSyxRQUFRLENBQUNDLE1BQVFDLFdBQVdELEtBQUtMO1lBQzdDLE9BQU87Z0JBQ0wsTUFBTXRELEtBQUssd0JBQXdCO1lBQ3JDO1FBQ0Y7SUFDRjtJQUNBLE1BQU0sSUFBSUwsTUFBTSxlQUF5QzBELE9BQTFCbkMsUUFBTyxxQkFBMkIsT0FBUm1DLFNBQVE7QUFDbkUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZmxvcmlcXERlc2t0b3BcXEJsb2NrY2hhaW5cXGJjc2NDYXJkYW5vXFxvZmYtY2hhaW5cXHNyY1xcdXRpbHNcXGNvbW1vbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSBcIm5vZGU6ZnNcIjtcclxuaW1wb3J0IHtcclxuICBBc3NldCxcclxuICBCbG9ja2Zyb3N0UHJvdmlkZXIsXHJcbiAgQnJvd3NlcldhbGxldCxcclxuICBtQ29uU3RyMCxcclxuICBNZXNoVHhCdWlsZGVyLFxyXG4gIE1lc2hXYWxsZXQsXHJcbiAgc2VyaWFsaXplUGx1dHVzU2NyaXB0LFxyXG4gIFBsdXR1c1NjcmlwdCxcclxuICByZXNvbHZlUGx1dHVzU2NyaXB0QWRkcmVzcyxcclxuICBVVHhPLFxyXG59IGZyb20gXCJAbWVzaHNkay9jb3JlXCI7XHJcbmltcG9ydCB7IGFwcGx5UGFyYW1zVG9TY3JpcHQsIHJlc29sdmVEYXRhSGFzaCB9IGZyb20gXCJAbWVzaHNkay9jb3JlLWNzbFwiO1xyXG5pbXBvcnQgYmV0Qmx1ZXByaW50IGZyb20gXCJAL3NjcmlwdHMvYmV0LnBsdXR1cy5qc29uXCI7XHJcbmltcG9ydCB7IHVzZVdhbGxldCB9IGZyb20gXCJAbWVzaHNkay9yZWFjdFwiO1xyXG4gXHJcbmNvbnN0IGJsb2NrY2hhaW5Qcm92aWRlciA9IG5ldyBCbG9ja2Zyb3N0UHJvdmlkZXIocHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkxPQ0tGUk9TVF9LRVkhKTtcclxuIFxyXG5sZXQgX3dhbGxldDogQnJvd3NlcldhbGxldCB8IG51bGwgPSBudWxsO1xyXG4vKipcclxuICogTGF6aWx5IGluaXRpYWxpemUgKGFuZCBjYWNoZSkgYSBCcm93c2VyV2FsbGV0IGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gd2FsbGV0TmFtZSDigJMgdGhlIENJUC0zMCB3YWxsZXQgZXh0ZW5zaW9uIGlkIChlLmcuICdsYWNlJywgJ25hbWknLCBldGMuKVxyXG4gKiBAdGhyb3dzIGlmIGNhbGxlZCBvbiB0aGUgc2VydmVyLCBvciBpZiB0aGUgZXh0ZW5zaW9uIGlzbuKAmXQgZm91bmQsIG9yIGlmIGVuYWJsZSgpIGZhaWxzXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QnJvd3NlcldhbGxldCh3YWxsZXROYW1lOiBzdHJpbmcgPSBcImxhY2VcIik6IFByb21pc2U8QnJvd3NlcldhbGxldD4ge1xyXG4gIC8vIDEpIERvbid0IHJ1biBpbiBTU1JcclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0QnJvd3NlcldhbGxldCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBpbiB0aGUgYnJvd3NlclwiKTtcclxuICB9XHJcblxyXG4gIC8vIDIpIFJldHVybiB0aGUgY2FjaGVkIHdhbGxldCBpZiBhbHJlYWR5IGNvbm5lY3RlZFxyXG4gIGlmIChfd2FsbGV0KSB7XHJcbiAgICByZXR1cm4gX3dhbGxldDtcclxuICB9XHJcblxyXG4gIC8vIDMpIE1ha2Ugc3VyZSB0aGUgZXh0ZW5zaW9uIGlzIGFjdHVhbGx5IGluamVjdGVkXHJcbiAgY29uc3QgaW5qZWN0ZWQgPSAod2luZG93IGFzIGFueSkuY2FyZGFubztcclxuICBpZiAoIWluamVjdGVkIHx8ICFpbmplY3RlZFt3YWxsZXROYW1lXSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICBgTm8gQ0lQLTMwIHByb3ZpZGVyIGZvdW5kIGZvciAnJHt3YWxsZXROYW1lfScuIGAgK1xyXG4gICAgICBgTWFrZSBzdXJlIHlvdSBoYXZlIHRoZSAke3dhbGxldE5hbWV9IGV4dGVuc2lvbiBpbnN0YWxsZWQgYW5kIGVuYWJsZWQuYFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8vIDQpIFRyeSB0byBlbmFibGUgKHRoaXMgd2lsbCBvcGVuIHRoZSDigJxDb25uZWN04oCdIHBvcHVwKVxyXG4gIHRyeSB7XHJcbiAgICBfd2FsbGV0ID0gYXdhaXQgQnJvd3NlcldhbGxldC5lbmFibGUod2FsbGV0TmFtZSk7XHJcbiAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgIGNvbnN0IG1zZyA9IGVycj8ubWVzc2FnZSB8fCBlcnI/LnRvU3RyaW5nKCkgfHwgXCJVbmtub3duIGVycm9yXCI7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBlbmFibGUgJyR7d2FsbGV0TmFtZX0nOiAke21zZ31gKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBfd2FsbGV0O1xyXG59XHJcbiBcclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjcmlwdDIoKSB7XHJcbiAgY29uc3Qgc2NyaXB0Q2JvciA9IGFwcGx5UGFyYW1zVG9TY3JpcHQoXHJcbiAgICBiZXRCbHVlcHJpbnQudmFsaWRhdG9yc1swXS5jb21waWxlZENvZGUsXHJcbiAgICBbXVxyXG4gICk7XHJcbiBcclxuICBjb25zdCBzY3JpcHRBZGRyID0gc2VyaWFsaXplUGx1dHVzU2NyaXB0KFxyXG4gICAgeyBjb2RlOiBzY3JpcHRDYm9yLCB2ZXJzaW9uOiBcIlYzXCIgfSxcclxuICApLmFkZHJlc3M7XHJcbiBcclxuICByZXR1cm4geyBzY3JpcHRDYm9yLCBzY3JpcHRBZGRyIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNjcmlwdCgpIHtcclxuICBjb25zdCBzY3JpcHRDYm9yID0gYXBwbHlQYXJhbXNUb1NjcmlwdChiZXRCbHVlcHJpbnQudmFsaWRhdG9yc1swXS5jb21waWxlZENvZGUsIFtdKTtcclxuXHJcbiAgY29uc3Qgc2NyaXB0OiBQbHV0dXNTY3JpcHQgPSB7XHJcbiAgICBjb2RlOiBzY3JpcHRDYm9yLFxyXG4gICAgdmVyc2lvbjogXCJWM1wiLFxyXG4gIH07XHJcbiAgY29uc3Qgc2NyaXB0QWRkciA9IHJlc29sdmVQbHV0dXNTY3JpcHRBZGRyZXNzKHNjcmlwdCwgMCk7XHJcbiAgcmV0dXJuIHsgc2NyaXB0LCBzY3JpcHRBZGRyIH07XHJcbn1cclxuIFxyXG4vLyByZXVzYWJsZSBmdW5jdGlvbiB0byBnZXQgYSB0cmFuc2FjdGlvbiBidWlsZGVyXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUeEJ1aWxkZXIoKSB7XHJcbiAgcmV0dXJuIG5ldyBNZXNoVHhCdWlsZGVyKHtcclxuICAgIGZldGNoZXI6IGJsb2NrY2hhaW5Qcm92aWRlcixcclxuICAgIHN1Ym1pdHRlcjogYmxvY2tjaGFpblByb3ZpZGVyLFxyXG4gIH0pO1xyXG59XHJcbiBcclxuLy8gcmV1c2FibGUgZnVuY3Rpb24gdG8gZ2V0IGEgVVR4TyBieSB0cmFuc2FjdGlvbiBoYXNoXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVdHhvQnlUeEhhc2godHhIYXNoOiBzdHJpbmcpOiBQcm9taXNlPFVUeE8+IHtcclxuICBjb25zdCB1dHhvcyA9IGF3YWl0IGJsb2NrY2hhaW5Qcm92aWRlci5mZXRjaFVUeE9zKHR4SGFzaCk7XHJcbiAgaWYgKHV0eG9zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVVR4TyBub3QgZm91bmRcIik7XHJcbiAgfVxyXG4gIHJldHVybiB1dHhvc1swXTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgRGF0dW0gPSBSZXR1cm5UeXBlPHR5cGVvZiBtQ29uU3RyMD47XHJcbmV4cG9ydCB0eXBlIERhdHVtQ29uc3RydWN0b3I8SW5wdXQ+ID0gKGlucHV0OiBJbnB1dCkgPT4gRGF0dW07XHJcbmV4cG9ydCB0eXBlIFZhcmlhZGljRGF0dW1Db25zdHJ1Y3RvcjxBcmdzIGV4dGVuZHMgYW55W10+ID0gKC4uLmFyZ3M6IEFyZ3MpID0+IERhdHVtO1xyXG5cclxuLyoqXHJcbiAqIExvY2tzIHRoZSBnaXZlbiBhc3NldHMgaW50byB5b3VyIG9u4oCQY2hhaW4gY29udHJhY3QsIHVzaW5nIHRoZSBwcm92aWRlZCBkYXR1bS5cclxuICpcclxuICogQHBhcmFtIGFzc2V0cyAgICAg4oCTIGFuIGFycmF5IG9mIGB7IHVuaXQ6IHN0cmluZzsgcXVhbnRpdHk6IHN0cmluZyB9YFxyXG4gKiBAcGFyYW0gZGF0dW1DdG9yICDigJMgYSBmdW5jdGlvbiB0aGF0LCBnaXZlbiBhbnkgaW5wdXQsIHJldHVybnMgdGhlIHNlcmlhbGl6ZWQgZGF0dW0geW91IHdhbnQgdG8gYXR0YWNoXHJcbiAqIEBwYXJhbSBkYXR1bUlucHV0IOKAkyB0aGUgcmF3IGlucHV0IHRoYXQgeW91ciBkYXR1bSBjb25zdHJ1Y3RvciBuZWVkcyAoZS5nLiBhIHB1YktleUhhc2gsIGEgbnVtYmVyLCB3aGF0ZXZlcilcclxuICogQHJldHVybnMgdGhlIHRyYW5zYWN0aW9uIGhhc2ggb2YgdGhlIGxvY2tcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2NrQXNzZXRzV2l0aERhdHVtPElucHV0PihcclxuICBhc3NldHM6IEFzc2V0W10sXHJcbiAgZGF0dW1DdG9yOiBEYXR1bUNvbnN0cnVjdG9yPElucHV0PixcclxuICBkYXR1bUlucHV0OiBJbnB1dFxyXG4pOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gIC8vIDEpIGdyYWIgVVRYT3MgYW5kIHlvdXIgY2hhbmdlIGFkZHJlc3NcclxuICBjb25zdCB1dHhvcyA9IGF3YWl0IF93YWxsZXQhLmdldFV0eG9zKCk7XHJcbiAgY29uc3QgW3dhbGxldEFkZHJlc3NdID0gYXdhaXQgX3dhbGxldCEuZ2V0VXNlZEFkZHJlc3NlcygpO1xyXG5cclxuICAvLyAyKSBnZXQgeW91ciBzY3JpcHQgKGFkZHJlc3MgKyB2YWxpZGF0b3IsIGV0Yy4pXHJcbiAgY29uc3QgeyBzY3JpcHRBZGRyIH0gPSBnZXRTY3JpcHQoKTtcclxuXHJcbiAgLy8gMykgYnVpbGQgdGhlIHRyYW5zYWN0aW9uXHJcbiAgY29uc3QgdHhCdWlsZGVyID0gZ2V0VHhCdWlsZGVyKClcclxuICAgIC50eE91dChzY3JpcHRBZGRyLCBhc3NldHMpICAgICAgICAgICAgICAgICAgIC8vIGZ1bmRzIOKGkiBzY3JpcHRcclxuICAgIC50eE91dERhdHVtSGFzaFZhbHVlKGRhdHVtQ3RvcihkYXR1bUlucHV0KSkgIC8vIGF0dGFjaCB5b3VyIGN1c3RvbSBkYXR1bVxyXG4gICAgLmNoYW5nZUFkZHJlc3Mod2FsbGV0QWRkcmVzcykgICAgICAgICAgICAgICAgLy8gcmV0dXJuIGNoYW5nZVxyXG4gICAgLnNlbGVjdFV0eG9zRnJvbSh1dHhvcyk7ICAgICAgICAgICAgICAgICAgICAgLy8gcGF5IGZyb20geW91ciBVVFhPc1xyXG5cclxuICBhd2FpdCB0eEJ1aWxkZXIuY29tcGxldGUoKTtcclxuXHJcbiAgLy8gNCkgc2lnbiAmIHN1Ym1pdFxyXG4gIGNvbnN0IHVuc2lnbmVkVHggPSB0eEJ1aWxkZXIudHhIZXg7XHJcbiAgY29uc3Qgc2lnbmVkVHggPSBhd2FpdCBfd2FsbGV0IS5zaWduVHgodW5zaWduZWRUeCk7XHJcbiAgY29uc3QgdHhIYXNoID0gYXdhaXQgX3dhbGxldCEuc3VibWl0VHgoc2lnbmVkVHgpO1xyXG5cclxuICByZXR1cm4gdHhIYXNoO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QXNzZXRVdHhvKHtcclxuICBzY3JpcHRBZGRyZXNzLFxyXG4gIGFzc2V0LFxyXG4gIGRhdHVtLFxyXG59OiB7XHJcbiAgc2NyaXB0QWRkcmVzczogc3RyaW5nO1xyXG4gIGFzc2V0OiBzdHJpbmc7XHJcbiAgZGF0dW06IGFueTtcclxufSkge1xyXG4gIGNvbnN0IHByb3ZpZGVyID0gYmxvY2tjaGFpblByb3ZpZGVyO1xyXG4gIGNvbnN0IHV0eG9zID0gYXdhaXQgcHJvdmlkZXIuZmV0Y2hBZGRyZXNzVVR4T3MoXHJcbiAgICBzY3JpcHRBZGRyZXNzLFxyXG4gICAgYXNzZXQsXHJcbiAgKTtcclxuICBjb25zb2xlLmxvZyhcIlVUeE9zIGF0IHNjcmlwdDpcIiwgdXR4b3MpO1xyXG4gIGNvbnN0IGRhdGFIYXNoID0gcmVzb2x2ZURhdGFIYXNoKGRhdHVtKTtcclxuICAvL2NvbnN0IGRhdGFIYXNoID0gXCJjMzRiNzYyMzBiOTY3MGEwOTdiZGJmYzllODVlYTVmN2UwMmRiYzAzOTk4MDY1OTRhM2M2MmVjN2ZkOTM0MDJhXCJcclxuICBjb25zb2xlLmxvZyhcIkxvb2tpbmcgZm9yIGRhdGFIYXNoOlwiLCByZXNvbHZlRGF0YUhhc2goZGF0dW0pKTtcclxuICAvL2RhdGFIYXNoID0gXCI3ODc2OWViNWU1YzA5YTlmNWI2ZTY1NThiYzE1MjdkNzlhMjBkNDI4ZjMyY2U3OGM0MDRkMGRkYmIzYmJjYzRmXCJcclxuICAvL2NvbnNvbGUubG9nKFwic2NyaXB0IGFkZHIgdXNlZDogXCIsIHNjcmlwdEFkZHJlc3MpXHJcbiBcclxuXHJcbiAgbGV0IHV0eG8gPSB1dHhvcy5maW5kKCh1dHhvOiBhbnkpID0+IHtcclxuICAgIHJldHVybiB1dHhvLm91dHB1dC5kYXRhSGFzaCA9PSBkYXRhSGFzaDtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHV0eG87XHJcbn1cclxuXHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXR4b0J5VHhIYXNoV2l0aFJldHJ5KHR4SGFzaDogc3RyaW5nLCByZXRyaWVzID0gMTAsIGRlbGF5ID0gMTUwMCk6IFByb21pc2U8YW55PiB7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXRyaWVzOyBpKyspIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJsb2NrY2hhaW5Qcm92aWRlci5mZXRjaFVUeE9zKHR4SGFzaCk7XHJcbiAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0WzBdOyAvLyBvcHB1cmUgZmlsdHJhcmUgcXVlbGxvIGdpdXN0byBzZSBjZSBuZSBzb25vIHBpw7lcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcclxuICAgICAgaWYgKGVyci5zdGF0dXMgPT09IDQwNCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBSZXRyeWluZyBmZXRjaFVUeE9CeVR4SGFzaC4uLiBbJHtpICsgMX0vJHtyZXRyaWVzfV1gKTtcclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzKSA9PiBzZXRUaW1lb3V0KHJlcywgZGVsYXkpKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBlcnI7IC8vIGVycm9yZSBkaXZlcnNvIGRhIDQwNFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gJHt0eEhhc2h9IG5vdCBmb3VuZCBhZnRlciAke3JldHJpZXN9IGF0dGVtcHRzLmApO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJCbG9ja2Zyb3N0UHJvdmlkZXIiLCJCcm93c2VyV2FsbGV0IiwiTWVzaFR4QnVpbGRlciIsInNlcmlhbGl6ZVBsdXR1c1NjcmlwdCIsInJlc29sdmVQbHV0dXNTY3JpcHRBZGRyZXNzIiwiYXBwbHlQYXJhbXNUb1NjcmlwdCIsInJlc29sdmVEYXRhSGFzaCIsImJldEJsdWVwcmludCIsImJsb2NrY2hhaW5Qcm92aWRlciIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19CTE9DS0ZST1NUX0tFWSIsIl93YWxsZXQiLCJnZXRCcm93c2VyV2FsbGV0Iiwid2FsbGV0TmFtZSIsIkVycm9yIiwiaW5qZWN0ZWQiLCJ3aW5kb3ciLCJjYXJkYW5vIiwiZW5hYmxlIiwiZXJyIiwibXNnIiwibWVzc2FnZSIsInRvU3RyaW5nIiwiZ2V0U2NyaXB0MiIsInNjcmlwdENib3IiLCJ2YWxpZGF0b3JzIiwiY29tcGlsZWRDb2RlIiwic2NyaXB0QWRkciIsImNvZGUiLCJ2ZXJzaW9uIiwiYWRkcmVzcyIsImdldFNjcmlwdCIsInNjcmlwdCIsImdldFR4QnVpbGRlciIsImZldGNoZXIiLCJzdWJtaXR0ZXIiLCJnZXRVdHhvQnlUeEhhc2giLCJ0eEhhc2giLCJ1dHhvcyIsImZldGNoVVR4T3MiLCJsZW5ndGgiLCJsb2NrQXNzZXRzV2l0aERhdHVtIiwiYXNzZXRzIiwiZGF0dW1DdG9yIiwiZGF0dW1JbnB1dCIsImdldFV0eG9zIiwid2FsbGV0QWRkcmVzcyIsImdldFVzZWRBZGRyZXNzZXMiLCJ0eEJ1aWxkZXIiLCJ0eE91dCIsInR4T3V0RGF0dW1IYXNoVmFsdWUiLCJjaGFuZ2VBZGRyZXNzIiwic2VsZWN0VXR4b3NGcm9tIiwiY29tcGxldGUiLCJ1bnNpZ25lZFR4IiwidHhIZXgiLCJzaWduZWRUeCIsInNpZ25UeCIsInN1Ym1pdFR4IiwiZ2V0QXNzZXRVdHhvIiwic2NyaXB0QWRkcmVzcyIsImFzc2V0IiwiZGF0dW0iLCJwcm92aWRlciIsImZldGNoQWRkcmVzc1VUeE9zIiwiY29uc29sZSIsImxvZyIsImRhdGFIYXNoIiwidXR4byIsImZpbmQiLCJvdXRwdXQiLCJnZXRVdHhvQnlUeEhhc2hXaXRoUmV0cnkiLCJyZXRyaWVzIiwiZGVsYXkiLCJpIiwicmVzdWx0Iiwic3RhdHVzIiwiUHJvbWlzZSIsInJlcyIsInNldFRpbWVvdXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/utils/common.ts\n"));

/***/ })

});