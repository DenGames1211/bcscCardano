"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./src/utils/lucid.ts":
/*!****************************!*\
  !*** ./src/utils/lucid.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SCRIPT_ADDRESS: () => (/* binding */ SCRIPT_ADDRESS),\n/* harmony export */   deployBetContract: () => (/* binding */ deployBetContract),\n/* harmony export */   encodeDatum: () => (/* binding */ encodeDatum),\n/* harmony export */   getScriptUtxos: () => (/* binding */ getScriptUtxos),\n/* harmony export */   initLucid: () => (/* binding */ initLucid),\n/* harmony export */   joinBet: () => (/* binding */ joinBet),\n/* harmony export */   timeoutBet: () => (/* binding */ timeoutBet),\n/* harmony export */   winBet: () => (/* binding */ winBet)\n/* harmony export */ });\n/* harmony import */ var lucid_cardano__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lucid-cardano */ \"(pages-dir-browser)/./node_modules/lucid-cardano/esm/mod.js\");\n/* harmony import */ var _scripts_bet_plutus_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/scripts/bet.plutus.json */ \"(pages-dir-browser)/./src/scripts/bet.plutus.json\");\n/* harmony import */ var _scripts_bet_plutus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/scripts/bet.plutus */ \"(pages-dir-browser)/./src/scripts/bet.plutus.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([lucid_cardano__WEBPACK_IMPORTED_MODULE_0__]);\nlucid_cardano__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n // JSON compilato\n\nlet lucidInstance;\nlet validatorAddress;\n// Configura il provider Blockfrost\nconst BLOCKFROST_URL = \"https://cardano-preview.blockfrost.io/api/v0\" || 0;\nconst BLOCKFROST_KEY = \"preview3G3NLFawCSyrtNMZb06OfRknAxZgy1fb\";\n// Indirizzo del tuo script Aiken (derivato dal Plutus script hash)\nconst SCRIPT_ADDRESS = \"addr_test1wrar992kj6gjcyczxd9gr302unaw7m09p3jrfvwwucuy6ccz5fklc\";\n// Costruisci un oggetto Script leggendo dal JSON\nconst validatorScript = {\n    type: _scripts_bet_plutus_json__WEBPACK_IMPORTED_MODULE_1__.type,\n    script: _scripts_bet_plutus_json__WEBPACK_IMPORTED_MODULE_1__.cborHex\n};\n/** Bech32 → payment key hash (hex string senza 0x) */ function getHashHexFromAddress(addr) {\n    var _details_paymentCredential;\n    const details = lucidInstance.utils.getAddressDetails(addr);\n    const hash = (_details_paymentCredential = details.paymentCredential) === null || _details_paymentCredential === void 0 ? void 0 : _details_paymentCredential.hash;\n    if (!hash) throw new Error('Impossibile estrarre paymentCredential.hash');\n    return hash.replace(/^0x/, '');\n}\nfunction encodeDatum(d) {\n    // Funzione di conversione sicura\n    const toBigInt = (value)=>{\n        if (typeof value === 'bigint') return value;\n        if (typeof value === 'number') return BigInt(Math.floor(value));\n        if (/^\\d+$/.test(value)) return BigInt(value);\n        throw new Error(\"Invalid numeric value: \".concat(value));\n    };\n    const shaped = {\n        index: 0,\n        fields: [\n            getHashHexFromAddress(d.oracle),\n            toBigInt(d.wager),\n            getHashHexFromAddress(d.player_1),\n            getHashHexFromAddress(d.player_2),\n            toBigInt(d.deadline),\n            {\n                index: d.isJoined ? 1 : 0,\n                fields: []\n            }\n        ]\n    };\n    return lucid_cardano__WEBPACK_IMPORTED_MODULE_0__.Data.to(shaped, _scripts_bet_plutus__WEBPACK_IMPORTED_MODULE_2__.BetBetSpend.datum);\n}\n/**\n * Inizializza Lucid e wallet (solo browser).\n */ async function initLucid() {\n    if (!lucidInstance) {\n        const provider = new lucid_cardano__WEBPACK_IMPORTED_MODULE_0__.Blockfrost(BLOCKFROST_URL, BLOCKFROST_KEY);\n        lucidInstance = await lucid_cardano__WEBPACK_IMPORTED_MODULE_0__.Lucid.new(provider, 'Preview');\n        if ( true && window.cardano) {\n            // Trova il wallet Lace o Nami compatibile\n            const wallet = window.cardano.lace || window.cardano.nami || Object.values(window.cardano).find((w)=>w.name === 'Nami' || w.name === 'Lace');\n            if (!wallet) throw new Error('Wallet compatibile non trovato');\n            const api = await wallet.enable();\n            validatorAddress = lucidInstance.utils.validatorToAddress(validatorScript);\n            lucidInstance.selectWallet(api);\n        }\n    }\n    return lucidInstance;\n}\n/**\n * Recupera tutti gli UTxO dal tuo script address.\n */ async function getScriptUtxos() {\n    const lucid = await initLucid();\n    return lucid.utxosAt(validatorAddress);\n}\nconst Listing = lucid_cardano__WEBPACK_IMPORTED_MODULE_0__.Data.Object({\n    owner: lucid_cardano__WEBPACK_IMPORTED_MODULE_0__.Data.Bytes(),\n    amount: lucid_cardano__WEBPACK_IMPORTED_MODULE_0__.Data.Integer(),\n    private: lucid_cardano__WEBPACK_IMPORTED_MODULE_0__.Data.Boolean()\n});\n/**\n * Costruisce e invia una transazione che spende/aggiorna l'UTxO sullo script.\n */ async function buildAndSubmit(datum, redeemer) {\n    const lucid = await initLucid();\n    const utxos = await lucid.utxosAt(validatorAddress);\n    const utxo = utxos.find((u)=>{\n        const d = u.datum;\n        return d && d.oracle === datum.oracle && d.deadline === datum.deadline;\n    });\n    if (!utxo) throw new Error('UTxO della scommessa non trovato');\n    const newDatum = encodeDatum(datum);\n    const tx = await lucid.newTx().attachSpendingValidator(validatorScript).collectFrom([\n        utxo\n    ], encodeRedeemer(redeemer)).payToContract(validatorAddress, encodeDatum(datum), {\n        lovelace: datum.wager * 2n\n    }).complete();\n}\n// -------------------------\n// AZIONI SUL VALIDATOR BET\n// -------------------------\n/** Join: constructor index 0 */ async function joinBet(d) {\n    const redeemer = {\n        Join: {\n            wager: d.wager\n        }\n    };\n    // buildAndSubmit ora deve accettare la stringa serializzata\n    return buildAndSubmit({\n        ...d,\n        isJoined: true\n    }, redeemer);\n}\n/** Win: constructor index 1 */ async function winBet(d, winner) {\n    const redeemer = {\n        Win: {\n            winner\n        }\n    };\n    return buildAndSubmit(d, redeemer);\n}\n/** Timeout: constructor index 2 */ async function timeoutBet(d) {\n    const redeemer = \"Timeout\";\n    return buildAndSubmit(d, redeemer);\n}\n/**\n * Deploy: crea un UTxO iniziale presso lo script con il datum iniziale.\n * @param d BetDatum iniziale\n * @param initialAda quantità di lovelace da inviare (default 2 ADA)\n */ async function deployBetContract(d) {\n    let initialAda = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2000000n;\n    const lucid = await initLucid();\n    console.log(\"received datum: \", d);\n    const tx = await lucid.newTx().attachSpendingValidator(validatorScript).payToContract(validatorAddress, encodeDatum(d), {\n        lovelace: initialAda\n    }).complete();\n    const signed = await tx.sign().complete();\n    return signed.submit();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy91dGlscy9sdWNpZC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRjtBQUM1QixDQUFDLGlCQUFpQjtBQUNyQjtBQUduRCxJQUFJSztBQUNKLElBQUlDO0FBRUosbUNBQW1DO0FBQ25DLE1BQU1DLGlCQUFpQkMsOENBQThDLElBQUksQ0FBOEM7QUFDdkgsTUFBTUcsaUJBQWlCSCx5Q0FBc0M7QUFFN0QsbUVBQW1FO0FBQzVELE1BQU1LLGlCQUFpQkwsaUVBQXNDLENBQUU7QUFFdEUsaURBQWlEO0FBQ2pELE1BQU1PLGtCQUEwQjtJQUM5QkMsTUFBTWIsMERBQWtCO0lBQ3hCYyxRQUFRZCw2REFBcUI7QUFDL0I7QUFFQSxvREFBb0QsR0FDcEQsU0FBU2dCLHNCQUFzQkMsSUFBWTtRQUU1QkM7SUFEYixNQUFNQSxVQUFVaEIsY0FBY2lCLEtBQUssQ0FBQ0MsaUJBQWlCLENBQUNIO0lBQ3RELE1BQU1JLFFBQU9ILDZCQUFBQSxRQUFRSSxpQkFBaUIsY0FBekJKLGlEQUFBQSwyQkFBMkJHLElBQUk7SUFDNUMsSUFBSSxDQUFDQSxNQUFNLE1BQU0sSUFBSUUsTUFBTTtJQUMzQixPQUFPRixLQUFLRyxPQUFPLENBQUMsT0FBTztBQUM3QjtBQUVPLFNBQVNDLFlBQVlDLENBQVc7SUFDckMsaUNBQWlDO0lBQ2pDLE1BQU1DLFdBQVcsQ0FBQ0M7UUFDaEIsSUFBSSxPQUFPQSxVQUFVLFVBQVUsT0FBT0E7UUFDdEMsSUFBSSxPQUFPQSxVQUFVLFVBQVUsT0FBT0MsT0FBT0MsS0FBS0MsS0FBSyxDQUFDSDtRQUN4RCxJQUFJLFFBQVFJLElBQUksQ0FBQ0osUUFBUSxPQUFPQyxPQUFPRDtRQUN2QyxNQUFNLElBQUlMLE1BQU0sMEJBQWdDLE9BQU5LO0lBQzVDO0lBRUEsTUFBTUssU0FBUztRQUNiQyxPQUFPO1FBQ1BDLFFBQVE7WUFDTm5CLHNCQUFzQlUsRUFBRVUsTUFBTTtZQUM5QlQsU0FBU0QsRUFBRVcsS0FB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QUFNaEIsV0FBd0I7UUFBRWlCLEtBQUs7WUFBRUQ7UUFBTztJQUFFO0lBQ2hELE9BQU9qQixlQUFlN0MsR0FBRzhDO0FBQzNCO0FBRUEsaUNBQWlDLEdBQzFCLGVBQWVrQixXQUFXaEUsQ0FBVztJQUMxQyxNQUFNOEMsV0FBd0I7SUFDOUIsT0FBT0QsZUFBZTdDLEdBQUc4QztBQUMzQjtBQUVBOzs7O0NBSUMsR0FDTSxlQUFlbUIsa0JBQWtCakUsQ0FBVztRQUFFa0UsYUFBQUEsaUVBQWEsUUFBVTtJQUMxRSxNQUFNOUIsUUFBUSxNQUFNbEI7SUFDcEJpRCxRQUFRQyxHQUFHLENBQUMsb0JBQW9CcEU7SUFFaEMsTUFBTW1ELEtBQUssTUFBTWYsTUFDZGdCLEtBQUssR0FDTEMsdUJBQXVCLENBQUNuRSxpQkFDeEJzRSxhQUFhLENBQ1ovRSxrQkFDQXNCLFlBQVlDLElBQ1o7UUFBRXlELFVBQVVTO0lBQVcsR0FFeEJSLFFBQVE7SUFFWCxNQUFNVyxTQUFTLE1BQU1sQixHQUFHbUIsSUFBSSxHQUFHWixRQUFRO0lBQ3ZDLE9BQU9XLE9BQU9FLE1BQU07QUFDdEIiLCJzb3VyY2VzIjpbIi9ob21lL2Rlbi9CQ1NDUHJvamVjdC9vZmYtY2hhaW4vc3JjL3V0aWxzL2x1Y2lkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEx1Y2lkLCBCbG9ja2Zyb3N0LCBEYXRhLCBTY3JpcHQsIGZyb21IZXgsIEFkZHJlc3MgfSBmcm9tICdsdWNpZC1jYXJkYW5vJztcbmltcG9ydCBiZXRTY3JpcHRKc29uIGZyb20gJ0Avc2NyaXB0cy9iZXQucGx1dHVzLmpzb24nOyAvLyBKU09OIGNvbXBpbGF0b1xuaW1wb3J0IHsgQmV0QmV0U3BlbmQgfSBmcm9tIFwiQC9zY3JpcHRzL2JldC5wbHV0dXNcIjtcbmltcG9ydCB0eXBlIHsgQmV0RGF0dW0sIEJldFJlZGVlbWVyIH0gZnJvbSAnQC9zY3JpcHRzL2JldC5wbHV0dXMnO1xuXG5sZXQgbHVjaWRJbnN0YW5jZTogTHVjaWQ7XG5sZXQgdmFsaWRhdG9yQWRkcmVzczogQWRkcmVzcztcblxuLy8gQ29uZmlndXJhIGlsIHByb3ZpZGVyIEJsb2NrZnJvc3RcbmNvbnN0IEJMT0NLRlJPU1RfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkxPQ0tGUk9TVF9ORVRXT1JLX1VSTCB8fCAnaHR0cHM6Ly9jYXJkYW5vLXByZXZpZXcuYmxvY2tmcm9zdC5pby9hcGkvdjAnO1xuY29uc3QgQkxPQ0tGUk9TVF9LRVkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CTE9DS0ZST1NUX0tFWSE7XG5cbi8vIEluZGlyaXp6byBkZWwgdHVvIHNjcmlwdCBBaWtlbiAoZGVyaXZhdG8gZGFsIFBsdXR1cyBzY3JpcHQgaGFzaClcbmV4cG9ydCBjb25zdCBTQ1JJUFRfQUREUkVTUyA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NDUklQVF9BRERSRVNTITtcblxuLy8gQ29zdHJ1aXNjaSB1biBvZ2dldHRvIFNjcmlwdCBsZWdnZW5kbyBkYWwgSlNPTlxuY29uc3QgdmFsaWRhdG9yU2NyaXB0OiBTY3JpcHQgPSB7XG4gIHR5cGU6IGJldFNjcmlwdEpzb24udHlwZSBhcyBTY3JpcHRbJ3R5cGUnXSxcbiAgc2NyaXB0OiBiZXRTY3JpcHRKc29uLmNib3JIZXhcbn07XG5cbi8qKiBCZWNoMzIg4oaSIHBheW1lbnQga2V5IGhhc2ggKGhleCBzdHJpbmcgc2VuemEgMHgpICovXG5mdW5jdGlvbiBnZXRIYXNoSGV4RnJvbUFkZHJlc3MoYWRkcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgZGV0YWlscyA9IGx1Y2lkSW5zdGFuY2UudXRpbHMuZ2V0QWRkcmVzc0RldGFpbHMoYWRkcik7XG4gIGNvbnN0IGhhc2ggPSBkZXRhaWxzLnBheW1lbnRDcmVkZW50aWFsPy5oYXNoO1xuICBpZiAoIWhhc2gpIHRocm93IG5ldyBFcnJvcignSW1wb3NzaWJpbGUgZXN0cmFycmUgcGF5bWVudENyZWRlbnRpYWwuaGFzaCcpO1xuICByZXR1cm4gaGFzaC5yZXBsYWNlKC9eMHgvLCAnJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVEYXR1bShkOiBCZXREYXR1bSk6IHN0cmluZyB7XG4gIC8vIEZ1bnppb25lIGRpIGNvbnZlcnNpb25lIHNpY3VyYVxuICBjb25zdCB0b0JpZ0ludCA9ICh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyIHwgYmlnaW50KTogYmlnaW50ID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JykgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSByZXR1cm4gQmlnSW50KE1hdGguZmxvb3IodmFsdWUpKTtcbiAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHJldHVybiBCaWdJbnQodmFsdWUpO1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1lcmljIHZhbHVlOiAke3ZhbHVlfWApO1xuICB9O1xuXG4gIGNvbnN0IHNoYXBlZCA9IHtcbiAgICBpbmRleDogMCxcbiAgICBmaWVsZHM6IFtcbiAgICAgIGdldEhhc2hIZXhGcm9tQWRkcmVzcyhkLm9yYWNsZSksIC8vIFZlcmlmaWNhIGNoZSBzaWEgZXNhdHRhbWVudGUgNTYgY2FyYXR0ZXJpXG4gICAgICB0b0JpZ0ludChkLndhZ2VyKSwgLy8gQ29udmVydGkgd2FnZXJcbiAgICAgIGdldEhhc2hIZXhGcm9tQWRkcmVzcyhkLnBsYXllcl8xKSxcbiAgICAgIGdldEhhc2hIZXhGcm9tQWRkcmVzcyhkLnBsYXllcl8yKSxcbiAgICAgIHRvQmlnSW50KGQuZGVhZGxpbmUpLCAvLyBDb252ZXJ0aSBkZWFkbGluZVxuICAgICAge1xuICAgICAgICBpbmRleDogZC5pc0pvaW5lZCA/IDEgOiAwLFxuICAgICAgICBmaWVsZHM6IFtdXG4gICAgICB9XG4gICAgXVxuICB9IGFzIGFueTtcblxuXG5cbiAgcmV0dXJuIERhdGEudG8oc2hhcGVkLCBCZXRCZXRTcGVuZC5kYXR1bSk7XG59XG5cbi8qKlxuICogSW5pemlhbGl6emEgTHVjaWQgZSB3YWxsZXQgKHNvbG8gYnJvd3NlcikuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0THVjaWQoKTogUHJvbWlzZTxMdWNpZD4ge1xuICBpZiAoIWx1Y2lkSW5zdGFuY2UpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBCbG9ja2Zyb3N0KEJMT0NLRlJPU1RfVVJMLCBCTE9DS0ZST1NUX0tFWSk7XG4gICAgbHVjaWRJbnN0YW5jZSA9IGF3YWl0IEx1Y2lkLm5ldyhwcm92aWRlciwgJ1ByZXZpZXcnKTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNhcmRhbm8pIHtcbiAgICAgIC8vIFRyb3ZhIGlsIHdhbGxldCBMYWNlIG8gTmFtaSBjb21wYXRpYmlsZVxuICAgICAgY29uc3Qgd2FsbGV0ID0gd2luZG93LmNhcmRhbm8ubGFjZSB8fCB3aW5kb3cuY2FyZGFuby5uYW1pIHx8IE9iamVjdC52YWx1ZXMod2luZG93LmNhcmRhbm8pLmZpbmQoKHc6IGFueSkgPT4gdy5uYW1lID09PSAnTmFtaScgfHwgdy5uYW1lID09PSAnTGFjZScpO1xuICAgICAgXG4gICAgICBpZiAoIXdhbGxldCkgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgY29tcGF0aWJpbGUgbm9uIHRyb3ZhdG8nKTtcblxuICAgICAgY29uc3QgYXBpID0gYXdhaXQgd2FsbGV0LmVuYWJsZSgpO1xuXG4gICAgICB2YWxpZGF0b3JBZGRyZXNzID0gbHVjaWRJbnN0YW5jZS51dGlscy52YWxpZGF0b3JUb0FkZHJlc3MoXG4gICAgICAgIHZhbGlkYXRvclNjcmlwdCxcbiAgICAgICk7XG4gICAgICBsdWNpZEluc3RhbmNlLnNlbGVjdFdhbGxldChhcGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbHVjaWRJbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBSZWN1cGVyYSB0dXR0aSBnbGkgVVR4TyBkYWwgdHVvIHNjcmlwdCBhZGRyZXNzLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2NyaXB0VXR4b3MoKSB7XG4gIGNvbnN0IGx1Y2lkID0gYXdhaXQgaW5pdEx1Y2lkKCk7XG4gIHJldHVybiBsdWNpZC51dHhvc0F0KHZhbGlkYXRvckFkZHJlc3MpO1xufVxuXG5jb25zdCBMaXN0aW5nID0gRGF0YS5PYmplY3Qoe1xuICBvd25lcjogRGF0YS5CeXRlcygpLFxuICBhbW91bnQ6IERhdGEuSW50ZWdlcigpLFxuICBwcml2YXRlOiBEYXRhLkJvb2xlYW4oKSxcbn0pO1xudHlwZSBMaXN0aW5nID0gdHlwZW9mIExpc3Rpbmc7XG5cbi8qKlxuICogQ29zdHJ1aXNjZSBlIGludmlhIHVuYSB0cmFuc2F6aW9uZSBjaGUgc3BlbmRlL2FnZ2lvcm5hIGwnVVR4TyBzdWxsbyBzY3JpcHQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkQW5kU3VibWl0KFxuICBkYXR1bTogQmV0RGF0dW0sXG4gIHJlZGVlbWVyOiBCZXRSZWRlZW1lclxuKSB7XG4gIGNvbnN0IGx1Y2lkID0gYXdhaXQgaW5pdEx1Y2lkKCk7XG4gIGNvbnN0IHV0eG9zID0gYXdhaXQgbHVjaWQudXR4b3NBdCh2YWxpZGF0b3JBZGRyZXNzKTtcbiAgY29uc3QgdXR4byA9IHV0eG9zLmZpbmQodSA9PiB7XG4gICAgY29uc3QgZCA9IHUuZGF0dW0gYXMgQmV0RGF0dW0gfCBudWxsO1xuICAgIHJldHVybiBkICYmIGQub3JhY2xlID09PSBkYXR1bS5vcmFjbGUgJiYgZC5kZWFkbGluZSA9PT0gZGF0dW0uZGVhZGxpbmU7XG4gIH0pO1xuICBpZiAoIXV0eG8pIHRocm93IG5ldyBFcnJvcignVVR4TyBkZWxsYSBzY29tbWVzc2Egbm9uIHRyb3ZhdG8nKTtcblxuICBjb25zdCBuZXdEYXR1bSA9IGVuY29kZURhdHVtKGRhdHVtKTtcbiAgY29uc3QgdHggPSBhd2FpdCBsdWNpZFxuICAubmV3VHgoKVxuICAuYXR0YWNoU3BlbmRpbmdWYWxpZGF0b3IodmFsaWRhdG9yU2NyaXB0KVxuICAuY29sbGVjdEZyb20oW3V0eG9dLCBlbmNvZGVSZWRlZW1lcihyZWRlZW1lcikpXG4gIC5wYXlUb0NvbnRyYWN0KFxuICAgIHZhbGlkYXRvckFkZHJlc3MsXG4gICAgZW5jb2RlRGF0dW0oZGF0dW0pLFxuICAgIHsgbG92ZWxhY2U6IGRhdHVtLndhZ2VyICogMm4gfVxuICApXG4gIC5jb21wbGV0ZSgpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBBWklPTkkgU1VMIFZBTElEQVRPUiBCRVRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqIEpvaW46IGNvbnN0cnVjdG9yIGluZGV4IDAgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBqb2luQmV0KGQ6IEJldERhdHVtKSB7XG4gIGNvbnN0IHJlZGVlbWVyOiBCZXRSZWRlZW1lciA9IHsgSm9pbjogeyB3YWdlcjogZC53YWdlciB9IH07XG4gIC8vIGJ1aWxkQW5kU3VibWl0IG9yYSBkZXZlIGFjY2V0dGFyZSBsYSBzdHJpbmdhIHNlcmlhbGl6emF0YVxuICByZXR1cm4gYnVpbGRBbmRTdWJtaXQoeyAuLi5kLCBpc0pvaW5lZDogdHJ1ZSB9LCByZWRlZW1lcik7XG59XG5cbi8qKiBXaW46IGNvbnN0cnVjdG9yIGluZGV4IDEgKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3aW5CZXQoZDogQmV0RGF0dW0sIHdpbm5lcjogc3RyaW5nKSB7XG4gIGNvbnN0IHJlZGVlbWVyOiBCZXRSZWRlZW1lciA9IHsgV2luOiB7IHdpbm5lciB9IH07XG4gIHJldHVybiBidWlsZEFuZFN1Ym1pdChkLCByZWRlZW1lcik7XG59XG5cbi8qKiBUaW1lb3V0OiBjb25zdHJ1Y3RvciBpbmRleCAyICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdGltZW91dEJldChkOiBCZXREYXR1bSkge1xuICBjb25zdCByZWRlZW1lcjogQmV0UmVkZWVtZXIgPSBcIlRpbWVvdXRcIjtcbiAgcmV0dXJuIGJ1aWxkQW5kU3VibWl0KGQsIHJlZGVlbWVyKTtcbn1cblxuLyoqXG4gKiBEZXBsb3k6IGNyZWEgdW4gVVR4TyBpbml6aWFsZSBwcmVzc28gbG8gc2NyaXB0IGNvbiBpbCBkYXR1bSBpbml6aWFsZS5cbiAqIEBwYXJhbSBkIEJldERhdHVtIGluaXppYWxlXG4gKiBAcGFyYW0gaW5pdGlhbEFkYSBxdWFudGl0w6AgZGkgbG92ZWxhY2UgZGEgaW52aWFyZSAoZGVmYXVsdCAyIEFEQSlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlcGxveUJldENvbnRyYWN0KGQ6IEJldERhdHVtLCBpbml0aWFsQWRhID0gMl8wMDBfMDAwbikge1xuICBjb25zdCBsdWNpZCA9IGF3YWl0IGluaXRMdWNpZCgpO1xuICBjb25zb2xlLmxvZyhcInJlY2VpdmVkIGRhdHVtOiBcIiwgZCk7XG5cbiAgY29uc3QgdHggPSBhd2FpdCBsdWNpZFxuICAgIC5uZXdUeCgpXG4gICAgLmF0dGFjaFNwZW5kaW5nVmFsaWRhdG9yKHZhbGlkYXRvclNjcmlwdClcbiAgICAucGF5VG9Db250cmFjdChcbiAgICAgIHZhbGlkYXRvckFkZHJlc3MsXG4gICAgICBlbmNvZGVEYXR1bShkKSxcbiAgICAgIHsgbG92ZWxhY2U6IGluaXRpYWxBZGEgfVxuICAgIClcbiAgICAuY29tcGxldGUoKTtcblxuICBjb25zdCBzaWduZWQgPSBhd2FpdCB0eC5zaWduKCkuY29tcGxldGUoKTtcbiAgcmV0dXJuIHNpZ25lZC5zdWJtaXQoKTtcbn1cblxuXG4iXSwibmFtZXMiOlsiTHVjaWQiLCJCbG9ja2Zyb3N0IiwiRGF0YSIsImJldFNjcmlwdEpzb24iLCJCZXRCZXRTcGVuZCIsImx1Y2lkSW5zdGFuY2UiLCJ2YWxpZGF0b3JBZGRyZXNzIiwiQkxPQ0tGUk9TVF9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQkxPQ0tGUk9TVF9ORVRXT1JLX1VSTCIsIkJMT0NLRlJPU1RfS0VZIiwiTkVYVF9QVUJMSUNfQkxPQ0tGUk9TVF9LRVkiLCJTQ1JJUFRfQUREUkVTUyIsIk5FWFRfUFVCTElDX1NDUklQVF9BRERSRVNTIiwidmFsaWRhdG9yU2NyaXB0IiwidHlwZSIsInNjcmlwdCIsImNib3JIZXgiLCJnZXRIYXNoSGV4RnJvbUFkZHJlc3MiLCJhZGRyIiwiZGV0YWlscyIsInV0aWxzIiwiZ2V0QWRkcmVzc0RldGFpbHMiLCJoYXNoIiwicGF5bWVudENyZWRlbnRpYWwiLCJFcnJvciIsInJlcGxhY2UiLCJlbmNvZGVEYXR1bSIsImQiLCJ0b0JpZ0ludCIsInZhbHVlIiwiQmlnSW50IiwiTWF0aCIsImZsb29yIiwidGVzdCIsInNoYXBlZCIsImluZGV4IiwiZmllbGRzIiwib3JhY2xlIiwid2FnZXIiLCJwbGF5ZXJfMSIsInBsYXllcl8yIiwiZGVhZGxpbmUiLCJpc0pvaW5lZCIsInRvIiwiZGF0dW0iLCJpbml0THVjaWQiLCJwcm92aWRlciIsIm5ldyIsIndpbmRvdyIsImNhcmRhbm8iLCJ3YWxsZXQiLCJsYWNlIiwibmFtaSIsIk9iamVjdCIsInZhbHVlcyIsImZpbmQiLCJ3IiwibmFtZSIsImFwaSIsImVuYWJsZSIsInZhbGlkYXRvclRvQWRkcmVzcyIsInNlbGVjdFdhbGxldCIsImdldFNjcmlwdFV0eG9zIiwibHVjaWQiLCJ1dHhvc0F0IiwiTGlzdGluZyIsIm93bmVyIiwiQnl0ZXMiLCJhbW91bnQiLCJJbnRlZ2VyIiwicHJpdmF0ZSIsIkJvb2xlYW4iLCJidWlsZEFuZFN1Ym1pdCIsInJlZGVlbWVyIiwidXR4b3MiLCJ1dHhvIiwidSIsIm5ld0RhdHVtIiwidHgiLCJuZXdUeCIsImF0dGFjaFNwZW5kaW5nVmFsaWRhdG9yIiwiY29sbGVjdEZyb20iLCJlbmNvZGVSZWRlZW1lciIsInBheVRvQ29udHJhY3QiLCJsb3ZlbGFjZSIsImNvbXBsZXRlIiwiam9pbkJldCIsIkpvaW4iLCJ3aW5CZXQiLCJ3aW5uZXIiLCJXaW4iLCJ0aW1lb3V0QmV0IiwiZGVwbG95QmV0Q29udHJhY3QiLCJpbml0aWFsQWRhIiwiY29uc29sZSIsImxvZyIsInNpZ25lZCIsInNpZ24iLCJzdWJtaXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/utils/lucid.ts\n"));

/***/ })

});