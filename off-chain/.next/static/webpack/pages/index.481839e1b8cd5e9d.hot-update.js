"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./src/utils/common.ts":
/*!*****************************!*\
  !*** ./src/utils/common.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAssetUtxo: () => (/* binding */ getAssetUtxo),\n/* harmony export */   getBrowserWallet: () => (/* binding */ getBrowserWallet),\n/* harmony export */   getScript: () => (/* binding */ getScript),\n/* harmony export */   getTxBuilder: () => (/* binding */ getTxBuilder),\n/* harmony export */   getUtxoByTxHash: () => (/* binding */ getUtxoByTxHash),\n/* harmony export */   lockAssetsWithDatum: () => (/* binding */ lockAssetsWithDatum)\n/* harmony export */ });\n/* harmony import */ var _meshsdk_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @meshsdk/core */ \"(pages-dir-browser)/./node_modules/@meshsdk/core/dist/index.js\");\n/* harmony import */ var _meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @meshsdk/core-csl */ \"(pages-dir-browser)/./node_modules/@meshsdk/core-csl/dist/index.js\");\n/* harmony import */ var _scripts_bet_plutus_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/scripts/bet.plutus.json */ \"(pages-dir-browser)/./src/scripts/bet.plutus.json\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__]);\n_meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\nconst blockchainProvider = new _meshsdk_core__WEBPACK_IMPORTED_MODULE_0__.BlockfrostProvider(\"preview3G3NLFawCSyrtNMZb06OfRknAxZgy1fb\");\nlet _wallet = null;\n/**\r\n * Lazily initialize (and cache) a BrowserWallet instance.\r\n *\r\n * @param walletName – the CIP-30 wallet extension id (e.g. 'lace', 'nami', etc.)\r\n * @throws if called on the server, or if the extension isn’t found, or if enable() fails\r\n */ async function getBrowserWallet() {\n    let walletName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"lace\";\n    // 1) Don't run in SSR\n    if (false) {}\n    // 2) Return the cached wallet if already connected\n    if (_wallet) {\n        return _wallet;\n    }\n    // 3) Make sure the extension is actually injected\n    const injected = window.cardano;\n    if (!injected || !injected[walletName]) {\n        throw new Error(\"No CIP-30 provider found for '\".concat(walletName, \"'. \") + \"Make sure you have the \".concat(walletName, \" extension installed and enabled.\"));\n    }\n    // 4) Try to enable (this will open the “Connect” popup)\n    try {\n        _wallet = await _meshsdk_core__WEBPACK_IMPORTED_MODULE_0__.BrowserWallet.enable(walletName);\n    } catch (err) {\n        const msg = (err === null || err === void 0 ? void 0 : err.message) || (err === null || err === void 0 ? void 0 : err.toString()) || \"Unknown error\";\n        throw new Error(\"Failed to enable '\".concat(walletName, \"': \").concat(msg));\n    }\n    return _wallet;\n}\nfunction getScript() {\n    const scriptCbor = (0,_meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__.applyParamsToScript)(_scripts_bet_plutus_json__WEBPACK_IMPORTED_MODULE_2__.validators[0].compiledCode, []);\n    const scriptAddr = (0,_meshsdk_core__WEBPACK_IMPORTED_MODULE_0__.serializePlutusScript)({\n        code: scriptCbor,\n        version: \"V3\"\n    }).address;\n    return {\n        scriptCbor,\n        scriptAddr\n    };\n}\n// reusable function to get a transaction builder\nfunction getTxBuilder() {\n    return new _meshsdk_core__WEBPACK_IMPORTED_MODULE_0__.MeshTxBuilder({\n        fetcher: blockchainProvider,\n        submitter: blockchainProvider\n    });\n}\n// reusable function to get a UTxO by transaction hash\nasync function getUtxoByTxHash(txHash) {\n    const utxos = await blockchainProvider.fetchUTxOs(txHash);\n    if (utxos.length === 0) {\n        throw new Error(\"UTxO not found\");\n    }\n    return utxos[0];\n}\n/**\r\n * Locks the given assets into your on‐chain contract, using the provided datum.\r\n *\r\n * @param assets     – an array of `{ unit: string; quantity: string }`\r\n * @param datumCtor  – a function that, given any input, returns the serialized datum you want to attach\r\n * @param datumInput – the raw input that your datum constructor needs (e.g. a pubKeyHash, a number, whatever)\r\n * @returns the transaction hash of the lock\r\n */ async function lockAssetsWithDatum(assets, datumCtor, datumInput) {\n    // 1) grab UTXOs and your change address\n    const utxos = await _wallet.getUtxos();\n    const [walletAddress] = await _wallet.getUsedAddresses();\n    // 2) get your script (address + validator, etc.)\n    const { scriptAddr } = getScript();\n    // 3) build the transaction\n    const txBuilder = getTxBuilder().txOut(scriptAddr, assets) // funds → script\n    .txOutDatumHashValue(datumCtor(datumInput)) // attach your custom datum\n    .changeAddress(walletAddress) // return change\n    .selectUtxosFrom(utxos); // pay from your UTXOs\n    await txBuilder.complete();\n    // 4) sign & submit\n    const unsignedTx = txBuilder.txHex;\n    const signedTx = await _wallet.signTx(unsignedTx);\n    const txHash = await _wallet.submitTx(signedTx);\n    return txHash;\n}\nasync function getAssetUtxo(param) {\n    let { scriptAddress, asset, datum } = param;\n    const provider = blockchainProvider;\n    const utxos = await provider.fetchAddressUTxOs(scriptAddress, asset);\n    console.log(\"UTxOs at script:\", utxos);\n    let dataHash = (0,_meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__.resolveDataHash)(datum);\n    console.log(\"Looking for dataHash:\", (0,_meshsdk_core_csl__WEBPACK_IMPORTED_MODULE_1__.resolveDataHash)(datum));\n    dataHash = \"78769eb5e5c09a9f5b6e6558bc1527d79a20d428f32ce78c404d0ddbb3bbcc4f\";\n    let utxo = utxos.find((utxo)=>{\n        return utxo.output.dataHash == dataHash;\n    });\n    return utxo;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy91dGlscy9jb21tb24udHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBVXVCO0FBQ2tEO0FBQ3BCO0FBR3JELE1BQU1PLHFCQUFxQixJQUFJUCw2REFBa0JBLENBQUNRLHlDQUFzQztBQUV4RixJQUFJRyxVQUFnQztBQUNwQzs7Ozs7Q0FLQyxHQUNNLGVBQWVDO1FBQWlCQyxhQUFBQSxpRUFBcUI7SUFDMUQsc0JBQXNCO0lBQ3RCLElBQUksS0FBNkIsRUFBRSxFQUVsQztJQUVELG1EQUFtRDtJQUNuRCxJQUFJRixTQUFTO1FBQ1gsT0FBT0E7SUFDVDtJQUVBLGtEQUFrRDtJQUNsRCxNQUFNSSxXQUFXLE9BQWdCRSxPQUFPO0lBQ3hDLElBQUksQ0FBQ0YsWUFBWSxDQUFDQSxRQUFRLENBQUNGLFdBQVcsRUFBRTtRQUN0QyxNQUFNLElBQUlDLE1BQ1IsaUNBQTRDLE9BQVhELFlBQVcsU0FDNUMsMEJBQXFDLE9BQVhBLFlBQVc7SUFFekM7SUFFQSx3REFBd0Q7SUFDeEQsSUFBSTtRQUNGRixVQUFVLE1BQU1WLHdEQUFhQSxDQUFDaUIsTUFBTSxDQUFDTDtJQUN2QyxFQUFFLE9BQU9NLEtBQVU7UUFDakIsTUFBTUMsTUFBTUQsQ0FBQUEsZ0JBQUFBLDBCQUFBQSxJQUFLRSxPQUFPLE1BQUlGLGdCQUFBQSwwQkFBQUEsSUFBS0csUUFBUSxPQUFNO1FBQy9DLE1BQU0sSUFBSVIsTUFBTSxxQkFBcUNNLE9BQWhCUCxZQUFXLE9BQVMsT0FBSk87SUFDdkQ7SUFFQSxPQUFPVDtBQUNUO0FBRU8sU0FBU1k7SUFDZCxNQUFNQyxhQUFhcEIsc0VBQW1CQSxDQUNwQ0UsZ0VBQXVCLENBQUMsRUFBRSxDQUFDb0IsWUFBWSxFQUN2QyxFQUFFO0lBR0osTUFBTUMsYUFBYXhCLG9FQUFxQkEsQ0FDdEM7UUFBRXlCLE1BQU1KO1FBQVlLLFNBQVM7SUFBSyxHQUNsQ0MsT0FBTztJQUVULE9BQU87UUFBRU47UUFBWUc7SUFBVztBQUNsQztBQUVBLGlEQUFpRDtBQUMxQyxTQUFTSTtJQUNkLE9BQU8sSUFBSTdCLHdEQUFhQSxDQUFDO1FBQ3ZCOEIsU0FBU3pCO1FBQ1QwQixXQUFXMUI7SUFDYjtBQUNGO0FBRUEsc0RBQXNEO0FBQy9DLGVBQWUyQixnQkFBZ0JDLE1BQWM7SUFDbEQsTUFBTUMsUUFBUSxNQUFNN0IsbUJBQW1COEIsVUFBVSxDQUFDRjtJQUNsRCxJQUFJQyxNQUFNRSxNQUFNLEtBQUssR0FBRztRQUN0QixNQUFNLElBQUl4QixNQUFNO0lBQ2xCO0lBQ0EsT0FBT3NCLEtBQUssQ0FBQyxFQUFFO0FBQ2pCO0FBTUE7Ozs7Ozs7Q0FPQyxHQUNNLGVBQWVHLG9CQUNwQkMsTUFBZSxFQUNmQyxTQUFrQyxFQUNsQ0MsVUFBaUI7SUFFakIsd0NBQXdDO0lBQ3hDLE1BQU1OLFFBQVEsTUFBTXpCLFFBQVNnQyxRQUFRO0lBQ3JDLE1BQU0sQ0FBQ0MsY0FBYyxHQUFHLE1BQU1qQyxRQUFTa0MsZ0JBQWdCO0lBRXZELGlEQUFpRDtJQUNqRCxNQUFNLEVBQUVsQixVQUFVLEVBQUUsR0FBR0o7SUFFdkIsMkJBQTJCO0lBQzNCLE1BQU11QixZQUFZZixlQUNmZ0IsS0FBSyxDQUFDcEIsWUFBWWEsUUFBMEIsaUJBQWlCO0tBQzdEUSxtQkFBbUIsQ0FBQ1AsVUFBVUMsYUFBYywyQkFBMkI7S0FDdkVPLGFBQWEsQ0FBQ0wsZUFBOEIsZ0JBQWdCO0tBQzVETSxlQUFlLENBQUNkLFFBQTRCLHNCQUFzQjtJQUVyRSxNQUFNVSxVQUFVSyxRQUFRO0lBRXhCLG1CQUFtQjtJQUNuQixNQUFNQyxhQUFhTixVQUFVTyxLQUFLO0lBQ2xDLE1BQU1DLFdBQVcsTUFBTTNDLFFBQVM0QyxNQUFNLENBQUNIO0lBQ3ZDLE1BQU1qQixTQUFTLE1BQU14QixRQUFTNkMsUUFBUSxDQUFDRjtJQUV2QyxPQUFPbkI7QUFDVDtBQUVPLGVBQWVzQixhQUFhLEtBUWxDO1FBUmtDLEVBQ2pDQyxhQUFhLEVBQ2JDLEtBQUssRUFDTEMsS0FBSyxFQUtOLEdBUmtDO0lBU2pDLE1BQU1DLFdBQVd0RDtJQUNqQixNQUFNNkIsUUFBUSxNQUFNeUIsU0FBU0MsaUJBQWlCLENBQzVDSixlQUNBQztJQUVGSSxRQUFRQyxHQUFHLENBQUMsb0JBQW9CNUI7SUFDaEMsSUFBSTZCLFdBQVc1RCxrRUFBZUEsQ0FBQ3VEO0lBQy9CRyxRQUFRQyxHQUFHLENBQUMseUJBQXlCM0Qsa0VBQWVBLENBQUN1RDtJQUNyREssV0FBVztJQUVYLElBQUlDLE9BQU85QixNQUFNK0IsSUFBSSxDQUFDLENBQUNEO1FBQ3JCLE9BQU9BLEtBQUtFLE1BQU0sQ0FBQ0gsUUFBUSxJQUFJQTtJQUNqQztJQUVBLE9BQU9DO0FBQ1QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcZmxvcmlcXERlc2t0b3BcXEJsb2NrY2hhaW5cXGJjc2NDYXJkYW5vXFxvZmYtY2hhaW5cXHNyY1xcdXRpbHNcXGNvbW1vbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSBcIm5vZGU6ZnNcIjtcclxuaW1wb3J0IHtcclxuICBBc3NldCxcclxuICBCbG9ja2Zyb3N0UHJvdmlkZXIsXHJcbiAgQnJvd3NlcldhbGxldCxcclxuICBtQ29uU3RyMCxcclxuICBNZXNoVHhCdWlsZGVyLFxyXG4gIE1lc2hXYWxsZXQsXHJcbiAgc2VyaWFsaXplUGx1dHVzU2NyaXB0LFxyXG4gIFVUeE8sXHJcbn0gZnJvbSBcIkBtZXNoc2RrL2NvcmVcIjtcclxuaW1wb3J0IHsgYXBwbHlQYXJhbXNUb1NjcmlwdCwgcmVzb2x2ZURhdGFIYXNoIH0gZnJvbSBcIkBtZXNoc2RrL2NvcmUtY3NsXCI7XHJcbmltcG9ydCBiZXRCbHVlcHJpbnQgZnJvbSBcIkAvc2NyaXB0cy9iZXQucGx1dHVzLmpzb25cIjtcclxuaW1wb3J0IHsgdXNlV2FsbGV0IH0gZnJvbSBcIkBtZXNoc2RrL3JlYWN0XCI7XHJcbiBcclxuY29uc3QgYmxvY2tjaGFpblByb3ZpZGVyID0gbmV3IEJsb2NrZnJvc3RQcm92aWRlcihwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CTE9DS0ZST1NUX0tFWSEpO1xyXG4gXHJcbmxldCBfd2FsbGV0OiBCcm93c2VyV2FsbGV0IHwgbnVsbCA9IG51bGw7XHJcbi8qKlxyXG4gKiBMYXppbHkgaW5pdGlhbGl6ZSAoYW5kIGNhY2hlKSBhIEJyb3dzZXJXYWxsZXQgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB3YWxsZXROYW1lIOKAkyB0aGUgQ0lQLTMwIHdhbGxldCBleHRlbnNpb24gaWQgKGUuZy4gJ2xhY2UnLCAnbmFtaScsIGV0Yy4pXHJcbiAqIEB0aHJvd3MgaWYgY2FsbGVkIG9uIHRoZSBzZXJ2ZXIsIG9yIGlmIHRoZSBleHRlbnNpb24gaXNu4oCZdCBmb3VuZCwgb3IgaWYgZW5hYmxlKCkgZmFpbHNcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRCcm93c2VyV2FsbGV0KHdhbGxldE5hbWU6IHN0cmluZyA9IFwibGFjZVwiKTogUHJvbWlzZTxCcm93c2VyV2FsbGV0PiB7XHJcbiAgLy8gMSkgRG9uJ3QgcnVuIGluIFNTUlxyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRCcm93c2VyV2FsbGV0KCkgY2FuIG9ubHkgYmUgY2FsbGVkIGluIHRoZSBicm93c2VyXCIpO1xyXG4gIH1cclxuXHJcbiAgLy8gMikgUmV0dXJuIHRoZSBjYWNoZWQgd2FsbGV0IGlmIGFscmVhZHkgY29ubmVjdGVkXHJcbiAgaWYgKF93YWxsZXQpIHtcclxuICAgIHJldHVybiBfd2FsbGV0O1xyXG4gIH1cclxuXHJcbiAgLy8gMykgTWFrZSBzdXJlIHRoZSBleHRlbnNpb24gaXMgYWN0dWFsbHkgaW5qZWN0ZWRcclxuICBjb25zdCBpbmplY3RlZCA9ICh3aW5kb3cgYXMgYW55KS5jYXJkYW5vO1xyXG4gIGlmICghaW5qZWN0ZWQgfHwgIWluamVjdGVkW3dhbGxldE5hbWVdKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgIGBObyBDSVAtMzAgcHJvdmlkZXIgZm91bmQgZm9yICcke3dhbGxldE5hbWV9Jy4gYCArXHJcbiAgICAgIGBNYWtlIHN1cmUgeW91IGhhdmUgdGhlICR7d2FsbGV0TmFtZX0gZXh0ZW5zaW9uIGluc3RhbGxlZCBhbmQgZW5hYmxlZC5gXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gNCkgVHJ5IHRvIGVuYWJsZSAodGhpcyB3aWxsIG9wZW4gdGhlIOKAnENvbm5lY3TigJ0gcG9wdXApXHJcbiAgdHJ5IHtcclxuICAgIF93YWxsZXQgPSBhd2FpdCBCcm93c2VyV2FsbGV0LmVuYWJsZSh3YWxsZXROYW1lKTtcclxuICB9IGNhdGNoIChlcnI6IGFueSkge1xyXG4gICAgY29uc3QgbXNnID0gZXJyPy5tZXNzYWdlIHx8IGVycj8udG9TdHJpbmcoKSB8fCBcIlVua25vd24gZXJyb3JcIjtcclxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGVuYWJsZSAnJHt3YWxsZXROYW1lfSc6ICR7bXNnfWApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIF93YWxsZXQ7XHJcbn1cclxuIFxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NyaXB0KCkge1xyXG4gIGNvbnN0IHNjcmlwdENib3IgPSBhcHBseVBhcmFtc1RvU2NyaXB0KFxyXG4gICAgYmV0Qmx1ZXByaW50LnZhbGlkYXRvcnNbMF0uY29tcGlsZWRDb2RlLFxyXG4gICAgW11cclxuICApO1xyXG4gXHJcbiAgY29uc3Qgc2NyaXB0QWRkciA9IHNlcmlhbGl6ZVBsdXR1c1NjcmlwdChcclxuICAgIHsgY29kZTogc2NyaXB0Q2JvciwgdmVyc2lvbjogXCJWM1wiIH0sXHJcbiAgKS5hZGRyZXNzO1xyXG4gXHJcbiAgcmV0dXJuIHsgc2NyaXB0Q2Jvciwgc2NyaXB0QWRkciB9O1xyXG59XHJcbiBcclxuLy8gcmV1c2FibGUgZnVuY3Rpb24gdG8gZ2V0IGEgdHJhbnNhY3Rpb24gYnVpbGRlclxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHhCdWlsZGVyKCkge1xyXG4gIHJldHVybiBuZXcgTWVzaFR4QnVpbGRlcih7XHJcbiAgICBmZXRjaGVyOiBibG9ja2NoYWluUHJvdmlkZXIsXHJcbiAgICBzdWJtaXR0ZXI6IGJsb2NrY2hhaW5Qcm92aWRlcixcclxuICB9KTtcclxufVxyXG4gXHJcbi8vIHJldXNhYmxlIGZ1bmN0aW9uIHRvIGdldCBhIFVUeE8gYnkgdHJhbnNhY3Rpb24gaGFzaFxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VXR4b0J5VHhIYXNoKHR4SGFzaDogc3RyaW5nKTogUHJvbWlzZTxVVHhPPiB7XHJcbiAgY29uc3QgdXR4b3MgPSBhd2FpdCBibG9ja2NoYWluUHJvdmlkZXIuZmV0Y2hVVHhPcyh0eEhhc2gpO1xyXG4gIGlmICh1dHhvcy5sZW5ndGggPT09IDApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIlVUeE8gbm90IGZvdW5kXCIpO1xyXG4gIH1cclxuICByZXR1cm4gdXR4b3NbMF07XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIERhdHVtID0gUmV0dXJuVHlwZTx0eXBlb2YgbUNvblN0cjA+O1xyXG5leHBvcnQgdHlwZSBEYXR1bUNvbnN0cnVjdG9yPElucHV0PiA9IChpbnB1dDogSW5wdXQpID0+IERhdHVtO1xyXG5leHBvcnQgdHlwZSBWYXJpYWRpY0RhdHVtQ29uc3RydWN0b3I8QXJncyBleHRlbmRzIGFueVtdPiA9ICguLi5hcmdzOiBBcmdzKSA9PiBEYXR1bTtcclxuXHJcbi8qKlxyXG4gKiBMb2NrcyB0aGUgZ2l2ZW4gYXNzZXRzIGludG8geW91ciBvbuKAkGNoYWluIGNvbnRyYWN0LCB1c2luZyB0aGUgcHJvdmlkZWQgZGF0dW0uXHJcbiAqXHJcbiAqIEBwYXJhbSBhc3NldHMgICAgIOKAkyBhbiBhcnJheSBvZiBgeyB1bml0OiBzdHJpbmc7IHF1YW50aXR5OiBzdHJpbmcgfWBcclxuICogQHBhcmFtIGRhdHVtQ3RvciAg4oCTIGEgZnVuY3Rpb24gdGhhdCwgZ2l2ZW4gYW55IGlucHV0LCByZXR1cm5zIHRoZSBzZXJpYWxpemVkIGRhdHVtIHlvdSB3YW50IHRvIGF0dGFjaFxyXG4gKiBAcGFyYW0gZGF0dW1JbnB1dCDigJMgdGhlIHJhdyBpbnB1dCB0aGF0IHlvdXIgZGF0dW0gY29uc3RydWN0b3IgbmVlZHMgKGUuZy4gYSBwdWJLZXlIYXNoLCBhIG51bWJlciwgd2hhdGV2ZXIpXHJcbiAqIEByZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiBoYXNoIG9mIHRoZSBsb2NrXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9ja0Fzc2V0c1dpdGhEYXR1bTxJbnB1dD4oXHJcbiAgYXNzZXRzOiBBc3NldFtdLFxyXG4gIGRhdHVtQ3RvcjogRGF0dW1Db25zdHJ1Y3RvcjxJbnB1dD4sXHJcbiAgZGF0dW1JbnB1dDogSW5wdXRcclxuKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAvLyAxKSBncmFiIFVUWE9zIGFuZCB5b3VyIGNoYW5nZSBhZGRyZXNzXHJcbiAgY29uc3QgdXR4b3MgPSBhd2FpdCBfd2FsbGV0IS5nZXRVdHhvcygpO1xyXG4gIGNvbnN0IFt3YWxsZXRBZGRyZXNzXSA9IGF3YWl0IF93YWxsZXQhLmdldFVzZWRBZGRyZXNzZXMoKTtcclxuXHJcbiAgLy8gMikgZ2V0IHlvdXIgc2NyaXB0IChhZGRyZXNzICsgdmFsaWRhdG9yLCBldGMuKVxyXG4gIGNvbnN0IHsgc2NyaXB0QWRkciB9ID0gZ2V0U2NyaXB0KCk7XHJcblxyXG4gIC8vIDMpIGJ1aWxkIHRoZSB0cmFuc2FjdGlvblxyXG4gIGNvbnN0IHR4QnVpbGRlciA9IGdldFR4QnVpbGRlcigpXHJcbiAgICAudHhPdXQoc2NyaXB0QWRkciwgYXNzZXRzKSAgICAgICAgICAgICAgICAgICAvLyBmdW5kcyDihpIgc2NyaXB0XHJcbiAgICAudHhPdXREYXR1bUhhc2hWYWx1ZShkYXR1bUN0b3IoZGF0dW1JbnB1dCkpICAvLyBhdHRhY2ggeW91ciBjdXN0b20gZGF0dW1cclxuICAgIC5jaGFuZ2VBZGRyZXNzKHdhbGxldEFkZHJlc3MpICAgICAgICAgICAgICAgIC8vIHJldHVybiBjaGFuZ2VcclxuICAgIC5zZWxlY3RVdHhvc0Zyb20odXR4b3MpOyAgICAgICAgICAgICAgICAgICAgIC8vIHBheSBmcm9tIHlvdXIgVVRYT3NcclxuXHJcbiAgYXdhaXQgdHhCdWlsZGVyLmNvbXBsZXRlKCk7XHJcblxyXG4gIC8vIDQpIHNpZ24gJiBzdWJtaXRcclxuICBjb25zdCB1bnNpZ25lZFR4ID0gdHhCdWlsZGVyLnR4SGV4O1xyXG4gIGNvbnN0IHNpZ25lZFR4ID0gYXdhaXQgX3dhbGxldCEuc2lnblR4KHVuc2lnbmVkVHgpO1xyXG4gIGNvbnN0IHR4SGFzaCA9IGF3YWl0IF93YWxsZXQhLnN1Ym1pdFR4KHNpZ25lZFR4KTtcclxuXHJcbiAgcmV0dXJuIHR4SGFzaDtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFzc2V0VXR4byh7XHJcbiAgc2NyaXB0QWRkcmVzcyxcclxuICBhc3NldCxcclxuICBkYXR1bSxcclxufToge1xyXG4gIHNjcmlwdEFkZHJlc3M6IHN0cmluZztcclxuICBhc3NldDogc3RyaW5nO1xyXG4gIGRhdHVtOiBhbnk7XHJcbn0pIHtcclxuICBjb25zdCBwcm92aWRlciA9IGJsb2NrY2hhaW5Qcm92aWRlcjtcclxuICBjb25zdCB1dHhvcyA9IGF3YWl0IHByb3ZpZGVyLmZldGNoQWRkcmVzc1VUeE9zKFxyXG4gICAgc2NyaXB0QWRkcmVzcyxcclxuICAgIGFzc2V0LFxyXG4gICk7XHJcbiAgY29uc29sZS5sb2coXCJVVHhPcyBhdCBzY3JpcHQ6XCIsIHV0eG9zKTtcclxuICBsZXQgZGF0YUhhc2ggPSByZXNvbHZlRGF0YUhhc2goZGF0dW0pO1xyXG4gIGNvbnNvbGUubG9nKFwiTG9va2luZyBmb3IgZGF0YUhhc2g6XCIsIHJlc29sdmVEYXRhSGFzaChkYXR1bSkpO1xyXG4gIGRhdGFIYXNoID0gXCI3ODc2OWViNWU1YzA5YTlmNWI2ZTY1NThiYzE1MjdkNzlhMjBkNDI4ZjMyY2U3OGM0MDRkMGRkYmIzYmJjYzRmXCJcclxuXHJcbiAgbGV0IHV0eG8gPSB1dHhvcy5maW5kKCh1dHhvOiBhbnkpID0+IHtcclxuICAgIHJldHVybiB1dHhvLm91dHB1dC5kYXRhSGFzaCA9PSBkYXRhSGFzaDtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHV0eG87XHJcbn0iXSwibmFtZXMiOlsiQmxvY2tmcm9zdFByb3ZpZGVyIiwiQnJvd3NlcldhbGxldCIsIk1lc2hUeEJ1aWxkZXIiLCJzZXJpYWxpemVQbHV0dXNTY3JpcHQiLCJhcHBseVBhcmFtc1RvU2NyaXB0IiwicmVzb2x2ZURhdGFIYXNoIiwiYmV0Qmx1ZXByaW50IiwiYmxvY2tjaGFpblByb3ZpZGVyIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0JMT0NLRlJPU1RfS0VZIiwiX3dhbGxldCIsImdldEJyb3dzZXJXYWxsZXQiLCJ3YWxsZXROYW1lIiwiRXJyb3IiLCJpbmplY3RlZCIsIndpbmRvdyIsImNhcmRhbm8iLCJlbmFibGUiLCJlcnIiLCJtc2ciLCJtZXNzYWdlIiwidG9TdHJpbmciLCJnZXRTY3JpcHQiLCJzY3JpcHRDYm9yIiwidmFsaWRhdG9ycyIsImNvbXBpbGVkQ29kZSIsInNjcmlwdEFkZHIiLCJjb2RlIiwidmVyc2lvbiIsImFkZHJlc3MiLCJnZXRUeEJ1aWxkZXIiLCJmZXRjaGVyIiwic3VibWl0dGVyIiwiZ2V0VXR4b0J5VHhIYXNoIiwidHhIYXNoIiwidXR4b3MiLCJmZXRjaFVUeE9zIiwibGVuZ3RoIiwibG9ja0Fzc2V0c1dpdGhEYXR1bSIsImFzc2V0cyIsImRhdHVtQ3RvciIsImRhdHVtSW5wdXQiLCJnZXRVdHhvcyIsIndhbGxldEFkZHJlc3MiLCJnZXRVc2VkQWRkcmVzc2VzIiwidHhCdWlsZGVyIiwidHhPdXQiLCJ0eE91dERhdHVtSGFzaFZhbHVlIiwiY2hhbmdlQWRkcmVzcyIsInNlbGVjdFV0eG9zRnJvbSIsImNvbXBsZXRlIiwidW5zaWduZWRUeCIsInR4SGV4Iiwic2lnbmVkVHgiLCJzaWduVHgiLCJzdWJtaXRUeCIsImdldEFzc2V0VXR4byIsInNjcmlwdEFkZHJlc3MiLCJhc3NldCIsImRhdHVtIiwicHJvdmlkZXIiLCJmZXRjaEFkZHJlc3NVVHhPcyIsImNvbnNvbGUiLCJsb2ciLCJkYXRhSGFzaCIsInV0eG8iLCJmaW5kIiwib3V0cHV0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/utils/common.ts\n"));

/***/ })

});